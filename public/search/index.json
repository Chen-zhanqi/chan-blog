[{"categories":[2022,"技术"],"contents":"网页版体验 微信小程序体验 如果没有编程基础，可以直接WX扫码使用封装好ChatGPT的小程序体验 1. OpenAI账号注册 OpenAI注册地址需要会翻墙，虚拟手机号接码。创建完账号则前往 API管理页面创建一个 API Key 并保存下来，后面需要在项目中配置这个key 2.运动环境 支持Linux、MacOS、Windows系统（可在Linux服务器上长期运行），同时需要安装Python。 1.克隆项目代码： git clone https://github.com/Chen-zhanqi/chatgpt-on-wechat.git cd chatgpt-on-wechat/ 2.安装所需核心依赖： pip3 install itchat-uos==1.5.0.dev0 pip3 install --upgrade openai 注：itchat-uos使用指定版本1.5.0.dev0，openai使用最新版本，需高于0.25.0。 3. 配置 配置文件的模板在根目录的config-template.json中，需复制该模板创建最终生效的 config.json 文件： cp config-template.json config.json 然后在config.json中填入配置，以下是对默认配置的说明，可根据需要进行自定义修改： # config.json文件内容示例 { \u0026#34;open_ai_api_key\u0026#34;: \u0026#34;YOUR API KEY\u0026#34;, # 填入上面创建的 OpenAI API KEY \u0026#34;single_chat_prefix\u0026#34;: [\u0026#34;bot\u0026#34;, \u0026#34;@bot\u0026#34;], # 私聊时文本需要包含该前缀才能触发机器人回复 \u0026#34;single_chat_reply_prefix\u0026#34;: \u0026#34;[bot] \u0026#34;, # 私聊时自动回复的前缀，用于区分真人 \u0026#34;group_chat_prefix\u0026#34;: [\u0026#34;@bot\u0026#34;], # 群聊时包含该前缀则会触发机器人回复 \u0026#34;group_name_white_list\u0026#34;: [\u0026#34;ChatGPT测试群\u0026#34;, \u0026#34;ChatGPT测试群2\u0026#34;], # 开启自动回复的群名称列表 \u0026#34;image_create_prefix\u0026#34;: [\u0026#34;画\u0026#34;, \u0026#34;看\u0026#34;, \u0026#34;找\u0026#34;], # 开启图片回复的前缀 \u0026#34;conversation_max_tokens\u0026#34;: 1000, # 支持上下文记忆的最多字符数 \u0026#34;character_desc\u0026#34;: \u0026#34;你是ChatGPT, 一个由OpenAI训练的大型语言模型, 你旨在回答并解决人们的任何问题，并且可以使用多种语言与人交流。\u0026#34; # 人格描述 } 配置说明： 1.个人聊天 个人聊天中，需要以 \u0026ldquo;bot\u0026quot;或\u0026rdquo;@bot\u0026quot; 为开头的内容触发机器人，对应配置项 single_chat_prefix (如果不需要以前缀触发可以填写 \u0026quot;single_chat_prefix\u0026quot;: [\u0026quot;\u0026quot;]) 机器人回复的内容会以 \u0026ldquo;[bot] \u0026quot; 作为前缀， 以区分真人，对应的配置项为 single_chat_reply_prefix (如果不需要前缀可以填写 \u0026quot;single_chat_reply_prefix\u0026quot;: \u0026quot;\u0026quot;) 2.群组聊天 群组聊天中，群名称需配置在 group_name_white_list 中才能开启群聊自动回复。如果想对所有群聊生效，可以直接填写 \u0026quot;group_name_white_list\u0026quot;: [\u0026quot;ALL_GROUP\u0026quot;] 默认只要被人 @ 就会触发机器人自动回复；另外群聊天中只要检测到以 \u0026ldquo;@bot\u0026rdquo; 开头的内容，同样会自动回复（方便自己触发），这对应配置项 group_chat_prefix 可选配置: group_name_keyword_white_list配置项支持模糊匹配群名称，group_chat_keyword配置项则支持模糊匹配群消息内容，用法与上述两个配置项相同。 3.其他配置 对于图像生成，在满足个人或群组触发条件外，还需要额外的关键词前缀来触发，对应配置 image_create_prefix 关于OpenAI对话及图片接口的参数配置（内容自由度、回复字数限制、图片大小等），可以参考 对话接口 和 图像接口 文档直接在bot/openai/open_ai_bot.py 中进行调整。 conversation_max_tokens：表示能够记忆的上下文最大字数（一问一答为一组对话，如果累积的对话字数超出限制，就会优先移除最早的一组对话） character_desc 配置中保存着你对机器人说的一段话，他会记住这段话并作为他的设定，你可以为他定制任何人格 4.运行 1.本地运行，直接在项目根目录下执行： python3 app.py 终端输出二维码后，使用微信进行扫码，当输出 \u0026ldquo;Start auto replying\u0026rdquo; 时表示自动回复程序已经成功运行了（注意：用于登录的微信需要在支付处已完成实名认证）。扫码登录后你的账号就成为机器人了，可以在微信手机端通过配置的关键词触发自动回复 (任意好友发送消息给你，或是自己发消息给好友)，下图表示登录成功。 更新 2023.3.15 本地正常运行，国内上个月开始无法访问openai域名了，所以需要开代理，不然会有 我无法访问你的网络 等错误提示。 微信图： 后端运行： ","permalink":"https://chenzqi.cn/posts/2022/chatgpt%E6%8E%A5%E5%85%A5%E5%BE%AE%E4%BF%A1%E6%9C%BA%E5%99%A8%E4%BA%BA/","tags":["chatgpt","ai"],"title":"ChatGPT接入微信机器人"},{"categories":[2022,"技术"],"contents":"cs gocron web\u0026amp;node gocron-web nohup ./gocron-linux-amd64/gocron web \u0026gt; /opt/server/gocron/log/gocron_web.log 2\u0026gt;\u0026amp;1 \u0026amp; gocron-node nohup sudo -u gocron ./gocron-node-linux-amd64/gocron-node \u0026gt; /opt/server/gocron/log/gocron_node.log 2\u0026gt;\u0026amp;1 \u0026amp; cs web vue cd /opt/docker/nginx/html/gin-web/ git pull docker restart nginx cs server gin cd /opt/server/gin-server git pull ps -ax | grep go kill *** nohup go run . \u0026gt;/dev/null 2\u0026gt;\u0026amp;1 \u0026amp; cs cccf-spider cd /opt/server/cccf-spider git pull ","permalink":"https://chenzqi.cn/posts/2022/cs%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/","tags":["golang","记录"],"title":"CS系统相关"},{"categories":[2022,"技术"],"contents":"备份脚本 #!/bin/sh # 备份存放位置 BACKUP_DIR=/data/backup/pg/ file=$BACKUP_DIR\u0026#34;gin_server_$(date +\u0026#34;%Y%m%d\u0026#34;).sql\u0026#34; docker exec -t postgres pg_dump -U pq_user -d db_name \u0026gt; \u0026#34;${file}\u0026#34; # 删除7天之前的备份 deleteDIR=$BACKUP_DIR\u0026#34;gin_server_$(date --date=\u0026#39;7 day ago\u0026#39; +%Y%m%d).sql\u0026#34; rm -rf $deleteDIR 恢复数据 正式数据库 cat gin_server_20190801.sql| docker exec -i postgres psql -U pq_user 其他数据库 创建数据库 create database dbname_prod_bak_20190722 owner username; grant all privileges on database dbname_prod_bak_20190722 to username; 恢复数据 cat gin_server_20190801.sql| docker exec -i postgres psql -U username -d dbname_prod_bak_20190722 ","permalink":"https://chenzqi.cn/posts/2022/docker-postgresql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/","tags":["docker","数据库"],"title":"docker-postgresql数据库备份与恢复"},{"categories":[2022,"技术"],"contents":"常用操作 docker容器下的PHP有自己特有的安装扩展方法： 进入php容器$：docker exec -it php /bin/bash docker-php-source： //在容器中创建/usr/src/php文件夹 docker-php-ext-install： //安装并启动扩展（常用） docker-php-ext-enable： //启动PHP扩展 docker-php-ext-configure： //添加扩展自定义配置，和enable搭配使用 zip 安装zip扩展所需的依赖扩展 apt-get update \u0026amp;\u0026amp; apt-get install -y zlib1g-dev \u0026amp;\u0026amp; apt-get install -y libzip-dev 安装并启动zip扩展 docker-php-ext-install zip pdo_mysql docker-php-ext-install pdo pdo_mysql 如果安装失败出现下面情况 /usr/local/bin/docker-php-ext-enable: cannot create /usr/local/etc/php/conf.d/docker-php-ext-pdo_mysql.ini: Directory nonexistent 解决方案： 在/usr/local/etc/php目录下面新建 conf.d 也可以把 docker-php-ext-pdo_mysql.ini 文件也创建了，文件内容： extension=pdo_mysql.so 修改完重新安装。 gd 相关报错 Call to undefined function think\\captcha\\imagecreate() 说明缺少gd扩展 安装依赖库 apt install -y libwebp-dev libjpeg-dev libpng-dev libfreetype6-dev 解压源码 docker-php-source extract 配置编译环境 docker-php-ext-configure gd --with-webp-dir=/usr/include/webp --with-jpeg-dir=/usr/include --with-png-dir=/usr/include --with-freetype-dir=/usr/include/freetype2 编译安装 docker-php-ext-install gd 查看结果 php -m | grep gd ","permalink":"https://chenzqi.cn/posts/2022/docker%E5%AE%B9%E5%99%A8%E4%B8%8Bphp%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C/","tags":["docker"],"title":"Docker容器下PHP扩展操作"},{"categories":[2022,"技术"],"contents":" 采用两级 channel，一级是将用户请求数据放入到 chan Job 中，这个 channel job 相当于待处理的任务队列。 另一级用来存放可以处理任务的 work 缓存队列，类型为 chan chan Job。调度器把待处理的任务放入一个空闲的缓存队列当中，work 会一直处理它的缓存队列。通过这种方式，实现了一个 worker 池。 请求: 把任务放入JobQueue package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;time\u0026#34; ) const ( MaxWorker = 100 // 随便设置值 MaxQueue = 200 // 随便设置值 ) // 一个可以发送工作请求的缓冲 channel var JobQueue chan Job func init() { JobQueue = make(chan Job, MaxQueue) } type Payload struct{} type Job struct { PayLoad Payload } // 接收请求，把任务筛入JobQueue。 func payloadHandler(w http.ResponseWriter, r *http.Request) { work := Job{PayLoad: Payload{}} JobQueue \u0026lt;- work _, _ = w.Write([]byte(\u0026#34;操作成功\u0026#34;)) } func main() { // 通过调度器创建worker，监听来自 JobQueue的任务 d := NewDispatcher() d.Run() http.HandleFunc(\u0026#34;/payload\u0026#34;, payloadHandler) log.Fatal(http.ListenAndServe(\u0026#34;:8099\u0026#34;, nil)) } Dispatcher调度器：循环读取JobQueue 一个Dispatcher 管理 多个Worker package main // 初始化操作 type Dispatcher struct { WorkerPool chan chan Job } func NewDispatcher() *Dispatcher { pool := make(chan chan Job, MaxWorker) return \u0026amp;Dispatcher{WorkerPool: pool} } func (d *Dispatcher) Run() { // 1. 开始运行 n 个 worker for i := 0; i \u0026lt; MaxWorker; i++ { worker := NewWorker(d.WorkerPool) worker.Start() } // 2. 循环读取JobQueue，随机选取一个Worker执行任务 go d.dispatch() } func (d *Dispatcher) dispatch() { for { select { case job := \u0026lt;-JobQueue: go func(job Job) { // 阻塞直到获取一个可用的worker job channel jobChannel := \u0026lt;-d.WorkerPool // 分发任务到 worker job channel 中 jobChannel \u0026lt;- job }(job) } } } Worker: 从Dispatcher获取任务 type Worker struct { WorkerPool chan chan Job JobChannel chan Job quit chan bool } func NewWorker(workerPool chan chan Job) Worker { return Worker{ WorkerPool: workerPool, JobChannel: make(chan Job), quit: make(chan bool), } } // 开启一个 worker 循环监听或退出channel func (w Worker) Start() { go func() { for { // 将当前的 worker 注册到 worker 队列中 w.WorkerPool \u0026lt;- w.JobChannel select { case job := \u0026lt;-w.JobChannel: // 真正业务的地方,模拟操作耗时 time.Sleep(500 * time.Millisecond) fmt.Printf(\u0026#34;上传成功:%v\\n\u0026#34;, job) case \u0026lt;-w.quit: return } } }() } func (w Worker) stop() { go func() { w.quit \u0026lt;- true }() } 来源 ","permalink":"https://chenzqi.cn/posts/2022/golang-%E6%8E%A5%E5%8F%A3%E8%AF%B7%E6%B1%82%E9%AB%98%E5%B9%B6%E5%8F%91/","tags":["golang"],"title":"Golang 接口请求高并发"},{"categories":[2022,"技术"],"contents":"Nginx 对于处理静态文件的效率要远高于 Web 框架，因为可以使用 gzip 压缩协议，减小静态文件的体积加快静态文件的加载速度、开启缓存和超时时间减少请求静态文件次数。 一 开启 gzip gzip on; #该指令用于开启或关闭gzip模块(on/off) gzip_buffers 16 8k; #设置系统获取几个单位的缓存用于存储gzip的压缩结果数据流。16 8k代表以8k为单位，安装原始数据大小以8k为单位的16倍申请内存 gzip_comp_level 6; #gzip压缩比，数值范围是1-9，1压缩比最小但处理速度最快，9压缩比最大但处理速度最慢 gzip_http_version 1.1; #识别http的协议版本 gzip_min_length 256; #设置允许压缩的页面最小字节数，页面字节数从header头得content-length中进行获取。默认值是0，不管页面多大都压缩。这里我设置了为256 gzip_proxied any; #这里设置无论header头是怎么样，都是无条件启用压缩 gzip_vary on; #在http header中添加Vary: Accept-Encoding ,给代理服务器用的 gzip_types text/xml application/xml application/atom+xml application/rss+xml application/xhtml+xml image/svg+xml text/javascript application/javascript application/x-javascript text/x-json application/json application/x-web-app-manifest+json text/css text/plain text/x-component font/opentype font/ttf application/x-font-ttf application/vnd.ms-fontobject image/x-icon; #进行压缩的文件类型,这里特别添加了对字体的文件类型 gzip_disable \u0026#34;MSIE [1-6]\\.(?!.*SV1)\u0026#34;; #禁用IE 6 gzip 二 开启超时时间 通过设置Expires，开启缓存。 location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf|flv|ico)$ { expires 30d; access_log off; } location ~ .*\\.(eot|ttf|otf|woff|svg)$ { expires 30d; access_log off; } location ~ .*\\.(js|css)?$ { expires 7d; access_log off; } ","permalink":"https://chenzqi.cn/posts/2022/nginx-%E4%BC%98%E5%8C%96%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE-/","tags":["nginx"],"title":"Nginx 优化静态文件访问"},{"categories":[2022,"技术"],"contents":"方法一： CREATE TABLE test_a ( id serial, name character varying(128), constraint pk_test_a_id primary key( id) ); 方法二： CREATE TABLE test_b( id serial PRIMARY KEY, name character varying(128) ); 这两种方法用的是pg的serial类型实现自增，drop表的时候指定的序列也会drop掉 方法三：先创建主键表 CREATE TABLE test_c ( id integer PRIMARY KEY, name character varying(128) ); 再手动创建序列 CREATE SEQUENCE test_c_id_seq START WITH 1 INCREMENT BY 1 NO MINVALUE NO MAXVALUE CACHE 1; 将序列赋值给主键 ALTER TABLE test_c alter column id set default nextval(\u0026#39;test_c_id_seq\u0026#39;); 这种方法在drop表的时候序列不会随着drop掉 ","permalink":"https://chenzqi.cn/posts/2022/postgresql-%E5%88%9B%E5%BB%BA%E4%B8%BB%E9%94%AE%E8%87%AA%E5%A2%9E%E7%9A%84%E8%A1%A8/","tags":["数据库"],"title":"postgresql-创建主键自增的表"},{"categories":[2022,"技术"],"contents":"终端（管理员）输入： slmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX slmgr /skms kms.03k.org slmgr /ato ","permalink":"https://chenzqi.cn/posts/2022/win10%E7%B3%BB%E7%BB%9F%E6%BF%80%E6%B4%BB%E6%8F%90%E7%A4%BA%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E5%88%B0%E4%BD%A0%E7%BB%84%E7%BB%87%E7%9A%84%E6%BF%80%E6%B4%BB%E6%9C%8D%E5%8A%A1%E5%99%A8-/","tags":["记录"],"title":"win10系统激活提示无法连接到你组织的激活服务器"},{"categories":[2022,"技术"],"contents":"采集数据样例 ","permalink":"https://chenzqi.cn/posts/2022/%E6%95%B0%E6%8D%AE%E6%A0%B7%E4%BE%8B/","tags":["记录"],"title":"数据样例"},{"categories":[2021],"contents":"package utils import ( \u0026#34;bytes\u0026#34; \u0026#34;encoding/json\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;time\u0026#34; ) func HttpRequest(method string, url string, data interface{}, result interface{}, header map[string]interface{}, queryParams map[string]interface{}) (response *http.Response, resMap interface{}, err error) { var client = http.Client{ Timeout: 3 * time.Second, } buf := bytes.NewBuffer(nil) encoder := json.NewEncoder(buf) if err = encoder.Encode(data); err != nil { return nil, nil, err } request, err := http.NewRequest(method, url, buf) if err != nil { return nil, nil, err } //request.Header.Add(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) if header != nil { for k, v := range header { request.Header.Add(k, v.(string)) } } if queryParams != nil { q := request.URL.Query() for k, v := range queryParams { q.Add(k, v.(string)) request.URL.RawQuery = q.Encode() } } response, err = client.Do(request) if err != nil { return nil, nil, err } if result != nil { defer response.Body.Close() res, err := ioutil.ReadAll(response.Body) if err != nil { return nil, nil, err } if err = json.Unmarshal(res, \u0026amp;result); err != nil { return nil, nil, err } //err = json.NewDecoder(response.Body).Decode(result) return response, result, err } return } ","permalink":"https://chenzqi.cn/posts/2021/20210620_go%E5%B0%81%E8%A3%85httprequest%E6%96%B9%E6%B3%95/","tags":["golang"],"title":"Go实现封装HttpRequest方法"},{"categories":[2021,"技术"],"contents":" 题号 题目 1 Golang中除了加Mutex锁以外还有哪些方式安全读写共享变量 2 无缓冲Chan的发送和接收是否同步 3 Golang并发机制以及它所使用的CSP并发模型 4 Golang中常用的并发模型 5 Go中对nil的Slice和空Slice的处理是一致的吗 6 协程和线程和进程的区别 7 Golang的内存模型中为什么小对象多了会造成GC压力 8 Go中数据竞争问题怎么解决 9 什么是channel，为什么它可以做到线程安全 10 Golang垃圾回收算法 11 GC的触发条件 12 Go的GPM如何调度 13 并发编程概念是什么 14 Go语言的栈空间管理是怎么样的 15 Goroutine和Channel的作用分别是什么 16 怎么查看Goroutine的数量 17 Go中的锁有哪些 18 怎么限制Goroutine的数量 19 Channel是同步的还是异步的 20 Goroutine和线程的区别 21 Go的Struct能不能比较 22 Go的defer原理是什么 23 Go的select可以用于什么 24 Go的Context包的用途是什么 25 Go主协程如何等其余协程完再操作 26 Go的Slice如何扩容 27 Go中的map如何实现顺序读取 28 Go中CAS是怎么回事 29 Go中的逃逸分析是什么 30 Go值接收者和指针接收者的区别 31 Go的对象在内存中是怎样分配的 32 栈的内存是怎么分配的 33 堆内存管理怎么分配的 34 Go中的defer函数使用下面的两种情况下结果是什么 35 在Go函数中为什么会发生内存泄露 36 Go中new和make的区别 37 G0的作用 38 Go中的锁如何实现 39 Go中的channel的实现 40 Go中的map的实现 41 Go中的http包的实现原理 42 Goroutine发生了泄漏如何检测 43 Go函数返回局部变量的指针是否安全 44 Go中两个Nil可能不相等吗 45 Goroutine和KernelThread之间是什么关系 46 为何GPM调度要有P 1 Golang中除了加Mutex锁以外还有哪些方式安全读写共享变量 Golang中Goroutine 可以通过 Channel 进行安全读写共享变量,还可以通过原子性操作进行. ","permalink":"https://chenzqi.cn/posts/2021/20210609_golang%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/","tags":["golang"],"title":"Golang问题汇总 - (持续更新...)"},{"categories":[2021,"技术"],"contents":"参数传递 Go在传递参数时是传值还是传引用，不同的选择会影响我们在函数中修改入参时是否会影响调用方看到的数据。 ::: tip 传值和传引用两者的区别 传值：函数调用时会对参数进行拷贝，被调用方和调用方两者持有不相关的两份数据； 传引用：函数调用时会传递参数的指针，被调用方和调用方两者持有相同的数据，任意一方做出的修改都会影响另一方； ::: 不同语言会选择不同的方式传递参数，Go 选择了传值的方式，无论是传递基本类型、结构体还是指针，都会对传递的参数进行拷贝。 整型和数组 函数 myFunction 接收了两个参数，整型变量 i 和数组 arr，这个函数会将传入的两个参数的地址打印出来，在最外层的主函数也会在 myFunction 函数调用前后分别打印两个参数的地址： func myFunction(i int, arr [2]int) { fmt.Printf(\u0026#34;in my_funciton - i=(%d, %p) arr=(%v, %p)\\n\u0026#34;, i, \u0026amp;i, arr, \u0026amp;arr) } func main() { i := 30 arr := [2]int{66, 77} fmt.Printf(\u0026#34;before calling - i=(%d, %p) arr=(%v, %p)\\n\u0026#34;, i, \u0026amp;i, arr, \u0026amp;arr) myFunction(i, arr) fmt.Printf(\u0026#34;after calling - i=(%d, %p) arr=(%v, %p)\\n\u0026#34;, i, \u0026amp;i, arr, \u0026amp;arr) } $ go run main.go before calling - i=(30, 0xc00009a000) arr=([66 77], 0xc00009a010) in my_funciton - i=(30, 0xc00009a008) arr=([66 77], 0xc00009a020) after calling - i=(30, 0xc00009a000) arr=([66 77], 0xc00009a010) main 函数和被调用者 myFunction 中参数的地址完全不同。 main 函数的角度来看，在调用 myFunction 前后，整数 i 和数组 arr 两个参数的地址都没有变化。 如果在 myFunction 函数内部对参数进行修改, 也仅仅影响了当前函数, 并没有影响调用方 main 函数。 ::: tip 结论 Go 语言的整型和数组类型都是值传递的，也就是在调用函数时会对内容进行拷贝。 ::: ::: warning 需要注意的是如果当前数组的大小非常的大，这种传值的方式会对性能造成比较大的影响。 ::: 结构体和指针 定义了一个结构体 MyStruct 以及接受两个参数的 myFunction 方法： type MyStruct struct { i int } func myFunction(a MyStruct, b *MyStruct) { a.i = 31 b.i = 41 fmt.Printf(\u0026#34;in my_function - a=(%d, %p) b=(%v, %p)\\n\u0026#34;, a, \u0026amp;a, b, \u0026amp;b) } func main() { a := MyStruct{i: 30} b := \u0026amp;MyStruct{i: 40} fmt.Printf(\u0026#34;before calling - a=(%d, %p) b=(%v, %p)\\n\u0026#34;, a, \u0026amp;a, b, \u0026amp;b) myFunction(a, b) fmt.Printf(\u0026#34;after calling - a=(%d, %p) b=(%v, %p)\\n\u0026#34;, a, \u0026amp;a, b, \u0026amp;b) } $ go run main.go before calling - a=({30}, 0xc000018178) b=(\u0026amp;{40}, 0xc00000c028) in my_function - a=({31}, 0xc000018198) b=(\u0026amp;{41}, 0xc00000c038) after calling - a=({30}, 0xc000018178) b=(\u0026amp;{41}, 0xc00000c028) ::: tip 结论 传递结构体时：会拷贝结构体中的全部内容； 传递结构体指针时：会拷贝结构体指针； ::: 修改结构体指针是改变了指针指向的结构体，b.i 可以被理解成 (*b).i，也就是我们先获取指针 b 背后的结构体，再修改结构体的成员变量。 传值 Go 语言在传递参数时使用了传值的方式，接收方收到参数时会对这些参数进行复制；在传递数组或者内存占用非常大的结构体时，尽量使用指针作为参数类型来避免发生数据拷贝进而影响性能。 ","permalink":"https://chenzqi.cn/posts/2021/20210519_go%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8-%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/","tags":["golang"],"title":"GO参数传递"},{"categories":[2021],"contents":"一、相关工具 navicat15-premium-cs.AppImage：Navicat 15 premium 官方简体中文试用版 navicat-patcher：补丁 navicat-keygen ：注册机 4.appimagetool-x86_64.AppImage：Linux 独立运行软件打包工具 相关工具下载地址 提取码： v587 二、系统环境配置 1.安装 capstone sudo apt-get install libcapstone-dev 2.安装 keystone sudo apt-get install cmake git clone https://github.com/keystone-engine/keystone.git cd keystone mkdir build cd build ../make-share.sh sudo make install sudo ldconfig 3.安装 rapidjson sudo apt-get install rapidjson-dev 三、操作步骤 1.赋予执行权限 chmod +x appimagetool-x86_64.AppImage chmod +x navicat-patcher chmod +x navicat-keygen 2.解压官方软件 mkdir navicat15 mount -o loop navicat15-premium-cs.AppImage navicat15 cp -r navicat15 navicat15-patched 3.运行补丁 (生成RegPrivateKey.pem文件) ./navicat-patcher navicat15-patched 4.打包成独立运行软件 ./appimagetool-x86_64.AppImage navicat15-patched navicat15-premium-cs-pathed.AppImage 5. 运行补丁后软件包 chmod +x navicat15-premium-cs-pathed.AppImage ./navicat15-premium-cs-pathed.AppImage 6.运行注册机 (打开新终端) ./navicat-keygen --text ./RegPrivateKey.pem @chenshen:~/apps/navicat/Navicat15$ ./navicat-keygen --text ./RegPrivateKey.pem ********************************************************** * Navicat Keygen (Linux) by @DoubleLabyrinth * * Version: 1.0 * ********************************************************** [*] Select Navicat product: 0. DataModeler 1. Premium 2. MySQL 3. PostgreSQL 4. Oracle 5. SQLServer 6. SQLite 7. MariaDB 8. MongoDB 9. ReportViewer (Input index)\u0026gt; 1 [*] Select product language: 0. English 1. Simplified Chinese 2. Traditional Chinese 3. Japanese 4. Polish 5. Spanish 6. French 7. German 8. Korean 9. Russian 10. Portuguese (Input index)\u0026gt; 1 [*] Input major version number: (range: 0 ~ 15, default: 12)\u0026gt; 15 [*] Serial number: NAVB-B5EA-NXXV-EFVY 7.生成序列号 (断网操作) 注册页面填入生成的注册码，超时后选择手动激活，输入请求码，两次回车生成激活码，填入后即可激活成功 ","permalink":"https://chenzqi.cn/posts/2021/20210506_liunx-navicat-premium-15-%E6%BF%80%E6%B4%BB/","tags":["工具","数据库"],"title":"Liunx Navicat premium 15 激活"},{"categories":[2021,"技术"],"contents":"简介 pyinstaller -F xxx.py 打包后会生成xxx.spec文件，，spec文件其实就相当于一个打包的架构文件，里面写了要怎么打包，类似于docker中的DockerFile。在用pyinstaller -F xxx.py这种方式打包的时候，程序也是先生成spec文件，再次打包的时候可以直接pyinstaller test.spec就可以。 步骤 新建crawl.py 在scrapy.cfg文件同一层，新建一个py文件，起名为 crawl.py # -*- coding: utf-8 -*- from scrapy.crawler import CrawlerProcess from scrapy.utils.project import get_project_settings # 这里是必须引入的 #import robotparser import scrapy.spiderloader import scrapy.statscollectors import scrapy.logformatter import scrapy.dupefilters import scrapy.squeues import scrapy.extensions.spiderstate import scrapy.extensions.corestats import scrapy.extensions.telnet import scrapy.extensions.logstats import scrapy.extensions.memusage import scrapy.extensions.memdebug import scrapy.extensions.feedexport import scrapy.extensions.closespider import scrapy.extensions.debug import scrapy.extensions.httpcache import scrapy.extensions.statsmailer import scrapy.extensions.throttle import scrapy.core.scheduler import scrapy.core.engine import scrapy.core.scraper import scrapy.core.spidermw import scrapy.core.downloader import scrapy.downloadermiddlewares.stats import scrapy.downloadermiddlewares.httpcache import scrapy.downloadermiddlewares.cookies import scrapy.downloadermiddlewares.useragent import scrapy.downloadermiddlewares.httpproxy import scrapy.downloadermiddlewares.ajaxcrawl #import scrapy.downloadermiddlewares.chunked import scrapy.downloadermiddlewares.decompression import scrapy.downloadermiddlewares.defaultheaders import scrapy.downloadermiddlewares.downloadtimeout import scrapy.downloadermiddlewares.httpauth import scrapy.downloadermiddlewares.httpcompression import scrapy.downloadermiddlewares.redirect import scrapy.downloadermiddlewares.retry import scrapy.downloadermiddlewares.robotstxt import scrapy.spidermiddlewares.depth import scrapy.spidermiddlewares.httperror import scrapy.spidermiddlewares.offsite import scrapy.spidermiddlewares.referer import scrapy.spidermiddlewares.urllength import scrapy.pipelines import scrapy.core.downloader.handlers.http import scrapy.core.downloader.contextfactory # 自己项目用到的包 import openpyxl import json import time import os process = CrawlerProcess(get_project_settings()) # \u0026#39;spider_name\u0026#39;替换成自己的爬虫名 process.crawl(\u0026#39;spider_name\u0026#39;) process.start() # the script will block here until the crawling is finished 打包crawl.py pyinstaller -F crawl.py -F 表示打包成单独的 .exe 文件 其他参数在本页面搜索框输入 程序打包 运行crawl.exe 1.双击运行，报错会闪退 2.打开新终端，将crawl.exe 托进去运行，可看见报错信息 问题 缺少文件 FileNotFoundError: [Errno 2] No such file or directory: \u0026#39;C:\\\\Users\\\\ADMINI~1\\\\Ap pData\\\\Local\\\\Temp\\\\_MEI77122\\\\scrapy\\\\VERSION\u0026#39; 少VERSION文件，这个VERSION文件安装的scrapy模块下的一个文件，在安装目录，比如scrapy文件都安装在这个目录下D:\\Program Files\\python374\\Lib\\site-packages\\scrapy。 可以在spec文件中直接配置 # -*- mode: python ; coding: utf-8 -*- block_cipher = None a = Analysis([\u0026#39;crawl.py\u0026#39;], pathex=[\u0026#39;C:\\\\Users\\\\Administrator\\\\Desktop\\\\qiaofenqi\u0026#39;], binaries=[], datas=[(\u0026#39;D:\\\\Program Files\\\\python374\\\\Lib\\\\site-packages\\\\scrapy\\\\mime.types\u0026#39;,\u0026#39;scrapy\u0026#39;), (\u0026#39;D:\\\\Program Files\\\\python374\\\\Lib\\\\site-packages\\\\scrapy\\\\VERSION\u0026#39;,\u0026#39;scrapy\u0026#39;), (\u0026#39;.\u0026#39;,\u0026#39;.\u0026#39; )], hiddenimports=[], hookspath=[], runtime_hooks=[], excludes=[], win_no_prefer_redirects=False, win_private_assemblies=False, cipher=block_cipher, noarchive=False) pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher) exe = EXE(pyz, a.scripts, a.binaries, a.zipfiles, a.datas, [], name=\u0026#39;crawl\u0026#39;, debug=False, bootloader_ignore_signals=False, strip=False, upx=True, upx_exclude=[], runtime_tmpdir=None, console=True ) 主要改的地方就是datas参数，要加入打包的资源文件，mime.types放到scrapy文件夹下，VERSION放到scrapy文件夹下，(’.’,’.’ )把当前目录放到打包后的根路径下，就是把整个爬虫文件打包进去。 重新打包，打包之前把上次产生的build和dist文件夹删掉，因为这里直接用的(’.’,’.’ )把整个文件都加了打包文件里了（乐意的话可以只把py文件加入datas，但目录结构不能变），会把build和dist也打进去，造成exe文件很大。 重新打包命令 pyinstaller crawl.spec 把xxx.exe文件拷贝到其他地方运行报错 KeyError: \u0026#39;Spider not found: credit\u0026#39; 爬虫运行是要依赖scrapy.cfg这个配置文件，把原来爬虫文件夹里的scrapy.cfg复制一下，和exe文件放到同目录下就可以 ","permalink":"https://chenzqi.cn/posts/2021/20210410_pyinstaller%E6%89%93%E5%8C%85scrapy%E9%A1%B9%E7%9B%AE/","tags":["python","pyinstaller"],"title":"pyinstaller打包scrapy项目"},{"categories":[2021,"技术"],"contents":"将本机文件复制到远程服务器上 # scp /home/administrator/news.txt root@127.0.0.1:/etc/squid /home/administrator/ 本地文件的绝对路径 news.txt 要复制到服务器上的本地文件 root 通过root用户登录到远程服务器（也可以使用其他拥有同等权限的用户） 127.0.0.1 远程服务器的ip地址（也可以使用域名或机器名） /etc/squid 将本地文件复制到位于远程服务器上的路径 将远程服务器上的文件复制到本机 # scp remote@www.abc.com:/usr/local/sin.sh /home/administrator remote 通过remote用户登录到远程服务器（也可以使用其他拥有同等权限的用户） 127.0.0.1 远程服务器ip地址 /usr/local/sin.sh 复制到本机的位于远程服务器上的文件 /home/administrator 将远程文件复制到本地的绝对路径 文件夹传输 文件夹操作加 -r 参数 ","permalink":"https://chenzqi.cn/posts/2021/20210326_scp%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/","tags":["nginx"],"title":"SCP-文件传输"},{"categories":[2021,"技术"],"contents":"生成与验证 data: 自定义数据, 如 {'username':user_name, 'user_id': user_info.id} 验证通过后在payload中获取 import jwt from datetime import datetime,timedelta SECRECT_KEY = b\u0026#39;\\x92R!\\x8e\\xc6\\x9c\\xb3\\x89#\\xa6\\x0c\\xcb\\xf6\\xcb\\xd7\\xc\u0026#39; def genToken(data): expInt = datetime.utcnow() + timedelta(days=1) iat = datetime.utcnow() payload = { \u0026#39;exp\u0026#39;: expInt, \u0026#39;iat\u0026#39;: iat, \u0026#39;data\u0026#39;: data } token = jwt.encode(payload, key = SECRECT_KEY, algorithm=\u0026#39;HS256\u0026#39;) return bytes.decode(token) def verfiyToken(tokenStr): try: if tokenStr is not None: tokenBytes = tokenStr.encode(\u0026#39;utf-8\u0026#39;) payload = jwt.decode(tokenBytes,SECRECT_KEY) return payload return None except jwt.PyJWTError as e: print(\u0026#34;jwt验证失败: %s\u0026#34; % e) return None ","permalink":"https://chenzqi.cn/posts/2021/20210320_jwt%E7%94%9F%E6%88%90%E4%B8%8E%E9%AA%8C%E8%AF%81/","tags":["web","python"],"title":"jwt 生成与验证 - Python"},{"categories":[2021,"技术"],"contents":"VSCode空格 问题： 空格太小，只占半个字符宽度 方法： 左上角 文件-\u0026gt;首选项-\u0026gt;设置,在搜索栏里搜font 把Editor:Font Family中默认的都删掉，只留下不带引号的monospace即可。 界面和编辑面板字体 问题： 新安装的VS Code字体很小，包括系统字体（标题栏，工具栏、状态栏）和编辑面板的字体很小 方法： Ctrl + Shitf + p，输入 settings，选择打开那个JSON的系统配置文件。 { \u0026#34;editor.fontSize\u0026#34;: 15, \u0026#34;window.zoomLevel\u0026#34;: 1.5 } 文件夹缩进 问题： 左侧文件树缩进太小 解决： 设置 \u0026gt; 搜索 \u0026ldquo;tree\u0026rdquo; \u0026gt; 修改 \u0026ldquo;Workbench › Tree: Indent\u0026rdquo; 值 ","permalink":"https://chenzqi.cn/posts/2021/20210312_vscode%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/","tags":["VSCode"],"title":"VSCode配置记录"},{"categories":[2021,"技术"],"contents":"禁止ip访问 server { listen 80 default; server_name _; return 500; } or server { listen 80 dufault; server_name _; rewrite ^(.*) http://www.xxx.cn permanent; } or server { listen 80 default; server_name _; server_name xxx.cn return 500; } 域名重定向 server { listen 80; server_name xxx.cn; if ($host = \u0026#39;xxx.cn\u0026#39; ) { rewrite ^/(.*)$ http://xx.xxx.com/$1 permanent; } } ","permalink":"https://chenzqi.cn/posts/2021/20210305_nginx%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/","tags":["nginx"],"title":"Nginx常见配置记录"},{"categories":[2020,"技术"],"contents":"::: tip 记录采集 XX法院网 反爬虫sign验证签名 ::: 签名验证反爬虫 签名验证的结果 签名是根据数据源进行计算或加密的过程，签名的结果是一个具有唯一性和一致性的字符串。签名结果的特征使得它成为验证数据来源和数据完整性的条件，可以有效避免服务器端将伪造的数据或篡改的数据当成正常数据处理。 签名验证的作用 签名验证时防止恶意连接和数据被篡改的有效方式之一，也是目前后端API最常见的防护方式之一。与Cookie，User-Aget，Host和Referer等请求头域不同，用于签名验证的信息通常被放在请求正文中发送到服务器端。 签名验证的方式 签名验证有很多种实现方式，但是原理都是相同的：由客服端生成一些随机值和不可逆的MD5加密字符串，并在发起请求时将这些值发送给服务器端。服务器端使用相同的方式对随机值进行计算以及MD5加密，如果服务器端得到的MD5值与前端提交的MD5值相同，就代表时正常请求，否则返回error或者403. def sign(value): sign_v = hashlib.md5(value.encode(encoding=\u0026#34;utf-8\u0026#34;)).hexdigest() return sign_v XX法院网 浏览器开发者模式断点调试, 分析生成签名的js相关代码, 漫长的分析, 分析步骤省略\u0026hellip; PY代码 python调用js, 生成sign签名 import hashlib import execjs import time # 10位数时间戳 t = int(time.time()) with open(\u0026#39;./chinacourt_sign.js\u0026#39;, \u0026#39;r\u0026#39;, encoding=\u0026#39;UTF-8\u0026#39;) as f: js = f.read() params = { \u0026#34;page\u0026#34;: 1, \u0026#34;level\u0026#34;: 3, \u0026#34;limit\u0026#34;: 50, \u0026#34;startTime\u0026#34;: \u0026#34;2021-01-26\u0026#34;, \u0026#34;endTime\u0026#34;: \u0026#34;2021-02-25\u0026#34;, \u0026#34;versionNumber\u0026#34;: \u0026#34;wap-v1\u0026#34; } ctx = execjs.compile(js) data = ctx.call(\u0026#34;MD5\u0026#34;, params, t) print(data) 输出 1614253292 {\u0026#39;page\u0026#39;: 1, \u0026#39;level\u0026#39;: 3, \u0026#39;limit\u0026#39;: 50, \u0026#39;startTime\u0026#39;: \u0026#39;2021-01-26\u0026#39;, \u0026#39;endTime\u0026#39;: \u0026#39;2021-02-25\u0026#39;, \u0026#39;versionNumber\u0026#39;: \u0026#39;wap-v1\u0026#39;, \u0026#39;signTime\u0026#39;: 1614253292, \u0026#39;sign\u0026#39;: \u0026#39;6EF27CEFAE958CE1B1244CBF39FC563B\u0026#39;} 请求接口时带上sign签名与相关参数 JS代码 浏览器分析整理后合并的JS代码, 放在一个js文件, 方便调用 function MD5(params, t) { var signParam = \u0026#34;\u0026#34;; // 最终的sign var bandParam = \u0026#34;478226dd02d159fb0c6d7fc675629a12f8723ecd\u0026#34;; var versionNumber = \u0026#34;wap-v1\u0026#34;; // params[\u0026#34;bandParam\u0026#34;] = bandParam; params[\u0026#34;versionNumber\u0026#34;] = versionNumber; params[\u0026#34;signTime\u0026#34;] = t; var sign = bandParam; var newData = [] for (var item in params) { newData.push(item); } newData.sort() for (var i = 0; i \u0026lt; newData.length; i++) { if ( Object.prototype.toString.call(params[newData[i]]) !== \u0026#34;[object Array]\u0026#34; \u0026amp;\u0026amp; Object.prototype.toString.call(params[newData[i]]) !== \u0026#34;[object Object]\u0026#34; ) { if (newData[i] !== \u0026#34;sign\u0026#34;) { sign += newData[i] + params[newData[i]]; } } } sign += bandParam; signParam = md5(sign).toUpperCase(); params[\u0026#34;sign\u0026#34;] = signParam; return params; }; function safeAdd(x, y) { var lsw = (x \u0026amp; 0xffff) + (y \u0026amp; 0xffff); var msw = (x \u0026gt;\u0026gt; 16) + (y \u0026gt;\u0026gt; 16) + (lsw \u0026gt;\u0026gt; 16); return (msw \u0026lt;\u0026lt; 16) | (lsw \u0026amp; 0xffff); } /* * Bitwise rotate a 32-bit number to the left. */ function bitRotateLeft(num, cnt) { return (num \u0026lt;\u0026lt; cnt) | (num \u0026gt;\u0026gt;\u0026gt; (32 - cnt)); } /* * These functions implement the four basic operations the algorithm uses. */ function md5cmn(q, a, b, x, s, t) { return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b); } function md5ff(a, b, c, d, x, s, t) { return md5cmn((b \u0026amp; c) | (~b \u0026amp; d), a, b, x, s, t); } function md5gg(a, b, c, d, x, s, t) { return md5cmn((b \u0026amp; d) | (c \u0026amp; ~d), a, b, x, s, t); } function md5hh(a, b, c, d, x, s, t) { return md5cmn(b ^ c ^ d, a, b, x, s, t); } function md5ii(a, b, c, d, x, s, t) { return md5cmn(c ^ (b | ~d), a, b, x, s, t); } /* * Calculate the MD5 of an array of little-endian words, and a bit length. */ function binlMD5(x, len) { /* append padding */ x[len \u0026gt;\u0026gt; 5] |= 0x80 \u0026lt;\u0026lt; len % 32; x[(((len + 64) \u0026gt;\u0026gt;\u0026gt; 9) \u0026lt;\u0026lt; 4) + 14] = len; var i; var olda; var oldb; var oldc; var oldd; var a = 1732584193; var b = -271733879; var c = -1732584194; var d = 271733878; for (i = 0; i \u0026lt; x.length; i += 16) { olda = a; oldb = b; oldc = c; oldd = d; a = md5ff(a, b, c, d, x[i], 7, -680876936); d = md5ff(d, a, b, c, x[i + 1], 12, -389564586); c = md5ff(c, d, a, b, x[i + 2], 17, 606105819); b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330); a = md5ff(a, b, c, d, x[i + 4], 7, -176418897); d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426); c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341); b = md5ff(b, c, d, a, x[i + 7], 22, -45705983); a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416); d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417); c = md5ff(c, d, a, b, x[i + 10], 17, -42063); b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162); a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682); d = md5ff(d, a, b, c, x[i + 13], 12, -40341101); c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290); b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329); a = md5gg(a, b, c, d, x[i + 1], 5, -165796510); d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632); c = md5gg(c, d, a, b, x[i + 11], 14, 643717713); b = md5gg(b, c, d, a, x[i], 20, -373897302); a = md5gg(a, b, c, d, x[i + 5], 5, -701558691); d = md5gg(d, a, b, c, x[i + 10], 9, 38016083); c = md5gg(c, d, a, b, x[i + 15], 14, -660478335); b = md5gg(b, c, d, a, x[i + 4], 20, -405537848); a = md5gg(a, b, c, d, x[i + 9], 5, 568446438); d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690); c = md5gg(c, d, a, b, x[i + 3], 14, -187363961); b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501); a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467); d = md5gg(d, a, b, c, x[i + 2], 9, -51403784); c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473); b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734); a = md5hh(a, b, c, d, x[i + 5], 4, -378558); d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463); c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562); b = md5hh(b, c, d, a, x[i + 14], 23, -35309556); a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060); d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353); c = md5hh(c, d, a, b, x[i + 7], 16, -155497632); b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640); a = md5hh(a, b, c, d, x[i + 13], 4, 681279174); d = md5hh(d, a, b, c, x[i], 11, -358537222); c = md5hh(c, d, a, b, x[i + 3], 16, -722521979); b = md5hh(b, c, d, a, x[i + 6], 23, 76029189); a = md5hh(a, b, c, d, x[i + 9], 4, -640364487); d = md5hh(d, a, b, c, x[i + 12], 11, -421815835); c = md5hh(c, d, a, b, x[i + 15], 16, 530742520); b = md5hh(b, c, d, a, x[i + 2], 23, -995338651); a = md5ii(a, b, c, d, x[i], 6, -198630844); d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415); c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905); b = md5ii(b, c, d, a, x[i + 5], 21, -57434055); a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571); d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606); c = md5ii(c, d, a, b, x[i + 10], 15, -1051523); b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799); a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359); d = md5ii(d, a, b, c, x[i + 15], 10, -30611744); c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380); b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649); a = md5ii(a, b, c, d, x[i + 4], 6, -145523070); d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379); c = md5ii(c, d, a, b, x[i + 2], 15, 718787259); b = md5ii(b, c, d, a, x[i + 9], 21, -343485551); a = safeAdd(a, olda); b = safeAdd(b, oldb); c = safeAdd(c, oldc); d = safeAdd(d, oldd); } return [a, b, c, d]; } /* * Convert an array of little-endian words to a string */ function binl2rstr(input) { var i; var output = \u0026#34;\u0026#34;; var length32 = input.length * 32; for (i = 0; i \u0026lt; length32; i += 8) { output += String.fromCharCode((input[i \u0026gt;\u0026gt; 5] \u0026gt;\u0026gt;\u0026gt; i % 32) \u0026amp; 0xff); } return output; } /* * Convert a raw string to an array of little-endian words * Characters \u0026gt;255 have their high-byte silently ignored. */ function rstr2binl(input) { var i; var output = []; output[(input.length \u0026gt;\u0026gt; 2) - 1] = undefined; for (i = 0; i \u0026lt; output.length; i += 1) { output[i] = 0; } var length8 = input.length * 8; for (i = 0; i \u0026lt; length8; i += 8) { output[i \u0026gt;\u0026gt; 5] |= (input.charCodeAt(i / 8) \u0026amp; 0xff) \u0026lt;\u0026lt; i % 32; } return output; } /* * Calculate the MD5 of a raw string */ function rstrMD5(s) { return binl2rstr(binlMD5(rstr2binl(s), s.length * 8)); } /* * Calculate the HMAC-MD5, of a key and some data (raw strings) */ function rstrHMACMD5(key, data) { var i; var bkey = rstr2binl(key); var ipad = []; var opad = []; var hash; ipad[15] = opad[15] = undefined; if (bkey.length \u0026gt; 16) { bkey = binlMD5(bkey, key.length * 8); } for (i = 0; i \u0026lt; 16; i += 1) { ipad[i] = bkey[i] ^ 0x36363636; opad[i] = bkey[i] ^ 0x5c5c5c5c; } hash = binlMD5(ipad.concat(rstr2binl(data)), 512 + data.length * 8); return binl2rstr(binlMD5(opad.concat(hash), 512 + 128)); } /* * Convert a raw string to a hex string */ function rstr2hex(input) { var hexTab = \u0026#34;0123456789abcdef\u0026#34;; var output = \u0026#34;\u0026#34;; var x; var i; for (i = 0; i \u0026lt; input.length; i += 1) { x = input.charCodeAt(i); output += hexTab.charAt((x \u0026gt;\u0026gt;\u0026gt; 4) \u0026amp; 0x0f) + hexTab.charAt(x \u0026amp; 0x0f); } return output; } /* * Encode a string as utf-8 */ function str2rstrUTF8(input) { return unescape(encodeURIComponent(input)); } /* * Take string arguments and return either raw or hex encoded strings */ function rawMD5(s) { return rstrMD5(str2rstrUTF8(s)); } function hexMD5(s) { return rstr2hex(rawMD5(s)); } function rawHMACMD5(k, d) { return rstrHMACMD5(str2rstrUTF8(k), str2rstrUTF8(d)); } function hexHMACMD5(k, d) { return rstr2hex(rawHMACMD5(k, d)); } function md5(string, key, raw) { if (!key) { if (!raw) { return hexMD5(string); } return rawMD5(string); } if (!raw) { return hexHMACMD5(key, string); } return rawHMACMD5(key, string); } if (typeof define === \u0026#34;function\u0026#34; \u0026amp;\u0026amp; define.amd) { define(function () { return md5; }); } else if (typeof module === \u0026#34;object\u0026#34; \u0026amp;\u0026amp; module.exports) { module.exports = md5; } else { $.md5 = md5; } ","permalink":"https://chenzqi.cn/posts/2020/20200810_%E7%A0%B4%E8%A7%A3%E6%9F%90%E6%B3%95%E9%99%A2%E7%BD%91sign%E7%AD%BE%E5%90%8D/","tags":["爬虫","解密"],"title":"破解某法院网sign签名"},{"categories":[2020,"技术"],"contents":"::: tip Qt designer 和 代码进行 Qt 开发实现页面跳转不同，本文记录 designer 开发 ::: PyQt5 多页面跳转 借助一个 Controller 控制器来实现，大体思路如下 # 利用一个控制器来控制页面的跳转 class Controller: def __init__(self): pass def show_A(self): # 创建 A 窗口对象并显示 # 关闭其余窗口对象 def show_B(self): # 创建 B 窗口对象并显示 # 关闭其余窗口对象 def show_C(self): # 创建 C 窗口对象并显示 # 关闭其余窗口对象 情景: 用 Qt designer 设计三个页面：hello.py、login.py、operate.py hello.py 中有一个 Id 为 loginBuuton 的按钮，用于跳转到 login.py 窗口 hello.py 中还有一个 Id 为 operateButton 的按钮，用于跳转到 operate.py 窗口 代码编写 导入需要的模块：系统模块 和 利用designer设计的页面 import sys from PyQt5 import QtCore, QtWidgets, QtCore # 导入 Qt designer 设计的页面 from hello import Ui_MainWindow as Hello_Ui from login import Ui_MainWindow as Login_Ui from operate import Ui_MainWindow as Operate_Ui 写页面对应的窗口类，实现 一个页面往其他页面的跳转； 实现跳转的逻辑主要都在 HelloWindow 类中，其他窗口类仅仅做了初始化： # 主窗口 class HelloWindow(QtWidgets.QMainWindow, Hello_Ui): switch_window1 = QtCore.pyqtSignal() # 跳转信号 switch_window2 = QtCore.pyqtSignal() # 跳转信号 def __init__(self): super(HelloWindow, self).__init__() self.setupUi(self) self.queryButton.clicked.connect(self.goOperate) self.manageButton.clicked.connect(self.goLogin) def goLogin(self): self.switch_window1.emit() def goOperate(self): self.switch_window2.emit() # 登录窗口 class LoginWindow(QtWidgets.QMainWindow, Login_Ui): def __init__(self): super(LoginWindow, self).__init__() self.setupUi(self) # 操作窗口 class OperateWindow(QtWidgets.QMainWindow, Operate_Ui): def __init__(self): super(OperateWindow, self).__init__() self.setupUi(self) 控制器用来控制页面的跳转： # 利用一个控制器来控制页面的跳转 class Controller: def __init__(self): pass # 跳转到 hello 窗口 def show_hello(self): self.hello = HelloWindow() self.hello.switch_window1.connect(self.show_login) self.hello.switch_window2.connect(self.show_operate) self.hello.show() # 跳转到 login 窗口, 注意关闭原页面 def show_login(self): self.login = LoginWindow() self.hello.close() self.login.show() # 跳转到 operate 窗口, 注意关闭原页面 def show_operate(self): self.operate = OperateWindow() self.hello.close() self.operate.show() 启动项目: def main(): app = QtWidgets.QApplication(sys.argv) controller = Controller() # 控制器实例 controller.show_hello() # 默认展示的是 hello 页面 sys.exit(app.exec_()) if __name__ == \u0026#39;__main__\u0026#39;: main() ","permalink":"https://chenzqi.cn/posts/2020/20200720_pyqt5%E5%A4%9A%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC/","tags":["python","mysql"],"title":"PyQt5多页面跳转"},{"categories":[2020,"技术"],"contents":"::: tip 每次连接mysql数据库请求时，都是独立的去请求访问，浪费资源，访问数量达到一定数量时，对mysql的性能会产生较大的影响。因此，通常会使用数据库的连接池技术，来访问数据库达到资源复用的目的。 ::: DBUtils DBUtils是一套Python数据库连接池包，并允许对非线程安全的数据库接口进行线程安全包装 DBUtils接口 PersistentDB ：提供线程专用的数据库连接，并自动管理连接。 PooledDB ：提供线程间可共享的数据库连接，并自动管理连接。 下载DBUtils DBUtils 实现 MySqlConn #!/usr/bin/env python # -*- coding:utf-8 -*- \u0026#34;\u0026#34;\u0026#34; @file: MySqlConn.py @time: @desc: None @Author: Chenzq @Wechat: 15690833097 @contact: czq181020@gmail.com \u0026#34;\u0026#34;\u0026#34; \u0026#34;\u0026#34;\u0026#34; 1、执行带参数的ＳＱＬ时，请先用sql语句指定需要输入的条件列表，然后再用tuple/list进行条件批配 ２、在格式ＳＱＬ中不需要使用引号指定数据类型，系统会根据输入参数自动识别 ３、在输入的值中不需要使用转意函数，系统会自动处理 \u0026#34;\u0026#34;\u0026#34; import pymysql from pymysql.cursors import DictCursor from DBUtils.PooledDB import PooledDB from . import Config class Mysql(object): \u0026#34;\u0026#34;\u0026#34; MYSQL数据库对象，负责产生数据库连接 , 此类中的连接采用连接池实现获取连接对象：conn = Mysql.getConn() 释放连接对象;conn.close()或del conn \u0026#34;\u0026#34;\u0026#34; # 连接池对象 __pool = None def __init__(self): # 数据库构造函数，从连接池中取出连接，并生成操作游标 self._conn = Mysql.__getConn() self._cursor = self._conn.cursor() @staticmethod def __getConn(): \u0026#34;\u0026#34;\u0026#34; @summary: 静态方法，从连接池中取出连接 @return MySQLdb.connection \u0026#34;\u0026#34;\u0026#34; if Mysql.__pool is None: __pool = PooledDB(creator=pymysql, mincached=1, maxcached=20, host=Config.MYSQL_HOST, port=Config.MYSQL_PORT, user=Config.MYSQL_USER, passwd=Config.MYSQL_PASSWORD, db=\u0026#34;rongyipai\u0026#34;, use_unicode=False, charset=Config.MYSQL_CHARSET, cursorclass=DictCursor) return __pool.connection() def getAll(self, sql, param=None): \u0026#34;\u0026#34;\u0026#34; @summary: 执行查询，并取出所有结果集 @param sql:查询ＳＱＬ，如果有查询条件，请只指定条件列表，并将条件值使用参数[param]传递进来 @param param: 可选参数，条件列表值（元组/列表） @return: result list(字典对象)/boolean 查询到的结果集 \u0026#34;\u0026#34;\u0026#34; if param is None: count = self._cursor.execute(sql) else: count = self._cursor.execute(sql, param) if count \u0026gt; 0: result = self._cursor.fetchall() else: result = False return result def getOne(self, sql, param=None): \u0026#34;\u0026#34;\u0026#34; @summary: 执行查询，并取出第一条 @param sql:查询ＳＱＬ，如果有查询条件，请只指定条件列表，并将条件值使用参数[param]传递进来 @param param: 可选参数，条件列表值（元组/列表） @return: result list/boolean 查询到的结果集 \u0026#34;\u0026#34;\u0026#34; if param is None: count = self._cursor.execute(sql) else: count = self._cursor.execute(sql, param) if count \u0026gt; 0: result = self._cursor.fetchone() else: result = False return result def getMany(self, sql, num, param=None): \u0026#34;\u0026#34;\u0026#34; @summary: 执行查询，并取出num条结果 @param sql:查询ＳＱＬ，如果有查询条件，请只指定条件列表，并将条件值使用参数[param]传递进来 @param num:取得的结果条数 @param param: 可选参数，条件列表值（元组/列表） @return: result list/boolean 查询到的结果集 \u0026#34;\u0026#34;\u0026#34; if param is None: count = self._cursor.execute(sql) else: count = self._cursor.execute(sql, param) if count \u0026gt; 0: result = self._cursor.fetchmany(num) else: result = False return result def insertOne(self, sql, value): \u0026#34;\u0026#34;\u0026#34; @summary: 向数据表插入一条记录 @param sql:要插入的ＳＱＬ格式 @param value:要插入的记录数据tuple/list @return: insertId 受影响的行数 \u0026#34;\u0026#34;\u0026#34; self._cursor.execute(sql, value) return self.__getInsertId() def insertMany(self, sql, values): \u0026#34;\u0026#34;\u0026#34; @summary: 向数据表插入多条记录 @param sql:要插入的ＳＱＬ格式 @param values:要插入的记录数据tuple(tuple)/list[list] @return: count 受影响的行数 \u0026#34;\u0026#34;\u0026#34; count = self._cursor.executemany(sql, values) return count def __getInsertId(self): \u0026#34;\u0026#34;\u0026#34; 获取当前连接最后一次插入操作生成的id,如果没有则为０ \u0026#34;\u0026#34;\u0026#34; self._cursor.execute(\u0026#34;SELECT @@IDENTITY AS id\u0026#34;) result = self._cursor.fetchall() return result[0][\u0026#39;id\u0026#39;] def __query(self, sql, param=None): if param is None: count = self._cursor.execute(sql) else: count = self._cursor.execute(sql, param) return count def update(self, sql, param=None): \u0026#34;\u0026#34;\u0026#34; @summary: 更新数据表记录 @param sql: ＳＱＬ格式及条件，使用(%s,%s) @param param: 要更新的 值 tuple/list @return: count 受影响的行数 \u0026#34;\u0026#34;\u0026#34; return self.__query(sql, param) def delete(self, sql, param=None): \u0026#34;\u0026#34;\u0026#34; @summary: 删除数据表记录 @param sql: ＳＱＬ格式及条件，使用(%s,%s) @param param: 要删除的条件 值 tuple/list @return: count 受影响的行数 \u0026#34;\u0026#34;\u0026#34; return self.__query(sql, param) def begin(self): \u0026#34;\u0026#34;\u0026#34; @summary: 开启事务 \u0026#34;\u0026#34;\u0026#34; self._conn.autocommit(0) def end(self, option=\u0026#39;commit\u0026#39;): \u0026#34;\u0026#34;\u0026#34; @summary: 结束事务 \u0026#34;\u0026#34;\u0026#34; if option == \u0026#39;commit\u0026#39;: self._conn.commit() else: self._conn.rollback() def dispose(self, isEnd=1): \u0026#34;\u0026#34;\u0026#34; @summary: 释放连接池资源 \u0026#34;\u0026#34;\u0026#34; if isEnd == 1: self.end(\u0026#39;commit\u0026#39;) else: self.end(\u0026#39;rollback\u0026#39;); self._cursor.close() self._conn.close() if __name__==\u0026#34;__main__\u0026#34;: mysql = Mysql() Config #!/usr/bin/env python # -*- coding:utf-8 -*- \u0026#34;\u0026#34;\u0026#34; @file: Config.py @desc: None @Author: Chenzq @Wechat: 15690833097 @contact: czq181020@gmail.com \u0026#34;\u0026#34;\u0026#34; MYSQL_HOST = \u0026#39;127.0.0.1\u0026#39; MYSQL_USER = \u0026#39;root\u0026#39; MYSQL_PASSWORD = \u0026#39;123456\u0026#39; MYSQL_DATABASE = \u0026#39;database\u0026#39; MYSQL_PORT = 3306 MYSQL_CHARSET = \u0026#39;utf8\u0026#39; test #coding:utf-8 from MySqlConn import Mysql from _sqlite3 import Row #申请资源 mysql = Mysql() sqlAll = \u0026#34;SELECT tb.uid as uid, group_concat(tb.goodsname) as goodsname FROM ( SELECT goods.uid AS uid, IF ( ISNULL(goodsrelation.goodsname), goods.goodsID, goodsrelation.goodsname ) AS goodsname FROM goods LEFT JOIN goodsrelation ON goods.goodsID = goodsrelation.goodsId ) tb GROUP BY tb.uid\u0026#34; result = mysql.getAll(sqlAll) if result : print \u0026#34;get all\u0026#34; for row in result : print \u0026#34;%s\\t%s\u0026#34;%(row[\u0026#34;uid\u0026#34;],row[\u0026#34;goodsname\u0026#34;]) sqlAll = \u0026#34;SELECT tb.uid as uid, group_concat(tb.goodsname) as goodsname FROM ( SELECT goods.uid AS uid, IF ( ISNULL(goodsrelation.goodsname), goods.goodsID, goodsrelation.goodsname ) AS goodsname FROM goods LEFT JOIN goodsrelation ON goods.goodsID = goodsrelation.goodsId ) tb GROUP BY tb.uid\u0026#34; result = mysql.getMany(sqlAll,2) if result : print \u0026#34;get many\u0026#34; for row in result : print \u0026#34;%s\\t%s\u0026#34;%(row[\u0026#34;uid\u0026#34;],row[\u0026#34;goodsname\u0026#34;]) result = mysql.getOne(sqlAll) print \u0026#34;get one\u0026#34; print \u0026#34;%s\\t%s\u0026#34;%(result[\u0026#34;uid\u0026#34;],result[\u0026#34;goodsname\u0026#34;]) #释放资源 mysql.dispose() ","permalink":"https://chenzqi.cn/posts/2020/20200710_mysql%E8%BF%9E%E6%8E%A5%E6%B1%A0/","tags":["python","mysql"],"title":"MySQL连接池"},{"categories":[2020,"技术"],"contents":"::: tip SQL写入与更新语句优化记录 ::: 数据 # 要写入的字典数据 data_dict = dict( fzID=data.get(\u0026#39;fzID\u0026#39;), statusCode=data.get(\u0026#39;statusCode\u0026#39;), statusName=data.get(\u0026#39;statusName\u0026#39;), thumb=data.get(\u0026#34;thumb\u0026#34;), atArea=data.get(\u0026#34;atArea\u0026#34;), buildingName=data.get(\u0026#34;buildingName\u0026#34;), communityName=data.get(\u0026#34;communityName\u0026#34;), areaSize=data.get(\u0026#34;areaSize\u0026#34;), startPrice=data.get(\u0026#34;startPrice\u0026#34;), currentPrice=data.get(\u0026#34;currentPrice\u0026#34;), unitPrice=data.get(\u0026#34;unitPrice\u0026#34;), buildingType=data.get(\u0026#34;buildingType\u0026#34;), bTypeName=data.get(\u0026#34;bTypeName\u0026#34;), taxesBy=data.get(\u0026#34;taxesBy\u0026#34;), taxesName=data.get(\u0026#34;taxesName\u0026#34;), canLoan=data.get(\u0026#34;canLoan\u0026#34;), LoanText=data.get(\u0026#34;LoanText\u0026#34;), discountRate=data.get(\u0026#34;discountRate\u0026#34;), puchaseLimit=data.get(\u0026#34;puchaseLimit\u0026#34;), countyName=countyName, startTime=data.get(\u0026#34;startTime\u0026#34;), endTime=data.get(\u0026#34;endTime\u0026#34;), editDate=data.get(\u0026#34;editDate\u0026#34;), competePersons=data.get(\u0026#34;competePersons\u0026#34;), callTimes=data.get(\u0026#34;callTimes\u0026#34;), yijialv=data.get(\u0026#34;yijialv\u0026#34;), ccode=data.get(\u0026#34;ccode\u0026#34;), ajklink=data.get(\u0026#34;ajklink\u0026#34;), bemetro=data.get(\u0026#34;bemetro\u0026#34;), jiaofu=jiaofu ) # data_dict = { # \u0026#39;fzID\u0026#39;: \u0026#39;6342304417171\u0026#39;, # \u0026#39;statusCode\u0026#39;: 2, # \u0026#39;statusName\u0026#39;: \u0026#39;即将开始\u0026#39;, # \u0026#39;thumb\u0026#39;: \u0026#39;https://img.51paimaifang.com/tb/202012/1810/tb6342304417171c00.jpg\u0026#39;, # \u0026#39;atArea\u0026#39;: \u0026#39;广东、深圳、龙岗\u0026#39;, # \u0026#39;buildingName\u0026#39;: \u0026#39;深圳市龙岗镇盛平村佳盛园D单元复式D803房\u0026#39;, # \u0026#39;communityName\u0026#39;: \u0026#39;育龙庭\u0026#39;, # \u0026#39;areaSize\u0026#39;: 114.09, # \u0026#39;startPrice\u0026#39;: 252.9696, # \u0026#39;currentPrice\u0026#39;: 252.9696, # \u0026#39;unitPrice\u0026#39;: 2.2172810938733, # \u0026#39;buildingType\u0026#39;: 1, # \u0026#39;bTypeName\u0026#39;: \u0026#39;住宅\u0026#39;, # \u0026#39;taxesBy\u0026#39;: 1, # \u0026#39;taxesName\u0026#39;: \u0026#39;税费全包\u0026#39;, # \u0026#39;canLoan\u0026#39;: 1, # \u0026#39;LoanText\u0026#39;: \u0026#39;一键贷款\u0026#39;, # \u0026#39;discountRate\u0026#39;: 8, # \u0026#39;puchaseLimit\u0026#39;: 1, # \u0026#39;countyName\u0026#39;: \u0026#39;龙岗\u0026#39;, # \u0026#39;startTime\u0026#39;: \u0026#39;2021/01/15 10:00:00\u0026#39;, # \u0026#39;endTime\u0026#39;: \u0026#39;2021/01/16 10:00:00\u0026#39;, # \u0026#39;editDate\u0026#39;: \u0026#39;2020/12/18 10:54\u0026#39;, # \u0026#39;competePersons\u0026#39;: 0, # \u0026#39;callTimes\u0026#39;: 0, # \u0026#39;yijialv\u0026#39;: -1, # \u0026#39;ccode\u0026#39;: \u0026#39;sz-2411051182955\u0026#39;, # \u0026#39;ajklink\u0026#39;: \u0026#39;https://shenzhen.anjuke.com/community/view/96690\u0026#39;, # \u0026#39;bemetro\u0026#39;: 1, # \u0026#39;jiaofu\u0026#39;: \u0026#39;交付\u0026#39; # } 常用方式 # 写入 insert_house = f\u0026#34;\u0026#34;\u0026#34; INSERT INTO houselist(fzID, statusCode, statusName, thumb, atArea, buildingName, communityName, areaSize, startPrice, currentPrice, unitPrice, buildingType, bTypeName, taxesBy, taxesName, canLoan, LoanText, discountRate, puchaseLimit, countyName, startTime, endTime, editDate, competePersons, callTimes, yijialv, ccode, ajklink, bemetro, jiaofu) VALUES ( {fzID}, {statusCode}, {statusName}, {thumb}, {atArea}, {buildingName}, {communityName}, {areaSize}, {startPrice}, {currentPrice}, {unitPrice}, {buildingType}, {bTypeName}, {taxesBy}, {taxesName}, {canLoan}, {LoanText}, {discountRate}, {puchaseLimit}, {countyName}, {startTime}, {endTime}, {editDate}, {competePersons}, {callTimes}, {yijialv}, {ccode}, {ajklink}, {bemetro}, {jiaofu} ) \u0026#34;\u0026#34;\u0026#34; # 执行语句 cursor.execute(insert_house) # 更新 update_house = f\u0026#34;\u0026#34;\u0026#34; UPDATE houselist SET fzID={fzID}, statusCode={statusCode}, statusName={statusName}, thumb={thumb}, atArea={atArea}, buildingName={buildingName}, communityName={communityName}, areaSize={areaSize}, startPrice={startPrice}, currentPrice={currentPrice}, unitPrice={unitPrice}, buildingType={buildingType}, bTypeName={bTypeName}, taxesBy={taxesBy}, taxesName={taxesName}, canLoan={canLoan}, LoanText={LoanText}, discountRate={discountRate}, puchaseLimit={puchaseLimit}, countyName={countyName}, startTime={startTime}, endTime={endTime}, editDate={editDate}, competePersons={competePersons}, callTimes={callTimes}, yijialv={yijialv}, ccode={ccode}, ajklink={ajklink}, bemetro={bemetro}, jiaofu={jiaofu} WHERE fzID={fzID} \u0026#34;\u0026#34;\u0026#34; # 执行语句 cursor.execute(update_house) 通用优化 # 写入 keys = \u0026#34;, \u0026#34;.join(data_dict.keys()) values = \u0026#39;, \u0026#39;.join([\u0026#39;%s\u0026#39;] * len(data_dict)) value = tuple([v for v in data_dict.values()]) insert_house = \u0026#39;INSERT INTO %s (%s) VALUES (%s)\u0026#39; % (\u0026#39;tablename\u0026#39;, keys, values) cursor.execute(insert_house, value) # 更新 kvs = \u0026#34;, \u0026#34;.join(list(map(lambda k: k + \u0026#34;=%s\u0026#34;, list(data_dict.keys())))) value = tuple([v for v in data_dict.values()]) update_house = \u0026#34;UPDATE %s SET %s WHERE fzID=%s\u0026#34; % (\u0026#34;tablename\u0026#34;, kvs, repr(data_dict.get(\u0026#39;fzID\u0026#39;))) cursor.execute(update_house, value) ","permalink":"https://chenzqi.cn/posts/2020/20200629_sql%E5%86%99%E5%85%A5%E4%B8%8E%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96/","tags":["python","mysql"],"title":"SQL写入与更新语句优化"},{"categories":[2020,"技术"],"contents":":::tip 服务器端解决跨域问题: django-cors-headers ::: 文档 django-cors-headers 安装 pip install -i https://pypi.douban.com/simple django-cors-headers 配置 settings.py 添加到已安装的应用程序中： INSTALLED_APPS = [ ... \u0026#39;corsheaders\u0026#39;， ... ] 确保添加结尾逗号，否则可能会收到一个逗号ModuleNotFoundError 添加一个中间件类来侦听响应： MIDDLEWARE = [ ... \u0026#39;corsheaders.middleware.CorsMiddleware\u0026#39;, \u0026#39;django.middleware.common.CommonMiddleware\u0026#39;, ... ] CorsMiddleware应该放置在尽可能高的位置，尤其是在可以生成响应的任何中间件之前 设置 CORS_ALLOW_ALL_ORIGINS CORS_ALLOW_ALL_ORIGINS = True 如果为True，则将允许所有来源。限制允许的原点的其他设置将被忽略。默认为False。 将其设置为True可能很危险，因为它允许任何网站向您的网站发出跨域请求。 通常，需要使用CORS_ALLOWED_ORIGINS或 限制允许的来源列表CORS_ALLOWED_ORIGIN_REGEXES。 旧版此设置称为 CORS_ORIGIN_ALLOW_ALL，仍然可以用作别名，新名称优先。 ","permalink":"https://chenzqi.cn/posts/2020/20200625_django%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E8%B7%A8%E5%9F%9F/","tags":["框架","Django","web"],"title":"Django服务器端跨域"},{"categories":[2020,"技术"],"contents":"::: tip 流行的跨域认证解决方案, JWT原理和用法 ::: JWT ::: tip Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519).该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。 ::: 传统session认证 互联网服务离不开用户认证, 一般流程 用户向服务器发送用户名和密码。 服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色.登录时间等等。 服务器向用户返回一个 session_id，写入用户的 Cookie。 用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。 服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。 ::: warning 这种模式的问题在于，扩展性（scaling）不好。单机没有问题，如果服务器集群，或者跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。 ::: ::: details 举例，A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？ 一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败 另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表 ::: token的鉴权机制 流程: 用户使用用户名密码来请求服务器 服务器进行验证用户的信息 服务器通过验证发送给用户一个token 客户端存储token，并在每次请求时附送上这个token值 服务端验证token值，并返回数据 token必须要在每次请求时传递给服务端，应该保存在请求头里， 另外，服务端要支持CORS(跨来源资源共享)策略，一般在服务端这么做就可以Access-Control-Allow-Origin: * JWT 原理 JWT 的原理: 服务器认证以后，生成一个 JSON 对象，发回给用户，如下 { \u0026#34;姓名\u0026#34;: \u0026#34;张三\u0026#34;, \u0026#34;角色\u0026#34;: \u0026#34;管理员\u0026#34;, \u0026#34;到期时间\u0026#34;: \u0026#34;2018年7月1日0点0分\u0026#34; } JWT 数据结构 中间用点（.）分隔成三个部分。JWT 内部没有换行，这里为了便于展示, 如下: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ JWT 的三个部分依次如下: Header（头部） Payload（负载） Signature（签名） JWT 特点 JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。 JWT 不加密的情况下，不能将秘密数据写入 JWT。 JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。 JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。 JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。 为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。 ","permalink":"https://chenzqi.cn/posts/2020/20200625_jsonwebtoken%E5%9F%BA%E7%A1%80/","tags":["web"],"title":"JSON Web Token"},{"categories":[2020,"技术"],"contents":":::tip Django REST Framework. Filters ::: 基本信息 源码 rest_framework.filters 官方文档 DRF API Guide-Filtering django-filter DRF 过滤组件 DRF 搜索过滤组件 urls.py from django.urls import path from . import views urlpatterns = [ path(\u0026#39;cars/\u0026#39;, views.CarListAPIView.as_view()), # SearchFilter ] views.py # drf的SearchFilter # 第一步： 搜索过滤 from rest_framework.filters import SearchFilter class CarListAPIView(ListAPIView): queryset = models.Car.objects.all() serializer_class = serializers.CarModelSerializer #自定义认证 # 第二步：局部配置 过滤类 们（全局配置用DEFAULT_FILTER_BACKENDS） filter_backends = [SearchFilter] # 第三步：SearchFilter过滤类依赖的过滤条件 =\u0026gt; 接口：/cars/?search=... search_fields = [\u0026#39;name\u0026#39;, \u0026#39;price\u0026#39;] #筛选字段 # eg：/cars/?search=1，name和price中包含1的数据都会被查询出 DRF 排序过滤组件 urls.py from django.urls import path from . import views urlpatterns = [ path(\u0026#39;cars2/\u0026#39;, views.CarListAPIView2.as_view()), # OrderingFilter ] views.py # 第一步：drf的OrderingFilter - 排序过滤 from rest_framework.filters import OrderingFilter class CarListAPIView2(ListAPIView): queryset = models.Car.objects.all() serializer_class = serializers.CarModelSerializer # 第二步：局部配置 过滤类 们（全局配置用DEFAULT_FILTER_BACKENDS） filter_backends = [OrderingFilter] # 第三步：OrderingFilter过滤类依赖的过滤条件 =\u0026gt; 接口：/cars/?ordering=... ordering_fields = [\u0026#39;pk\u0026#39;, \u0026#39;price\u0026#39;] # eg：/cars/?ordering=-price,pk，先按price降序，如果出现price相同，再按pk升序 自定义过滤器 urls.py from django.urls import path from . import views urlpatterns = [ path(\u0026#39;cars3/\u0026#39;, views.CarListAPIView3.as_view()), # 自定义fitler ] filters.py from . import models # 自定义过滤器，接口：?limit=显示的条数 class LimitFilter: def filter_queryset(self, request, queryset, view): # 前台固定用 ?limit=... 传递过滤参数 limit = request.query_params.get(\u0026#39;limit\u0026#39;) if limit: limit = int(limit) return queryset[:limit] return queryset views.py # 自定义fitler from .filters import LimitFilter class CarListAPIView3(ListAPIView): # 如果queryset没有过滤条件，就必须 .all()，不然分页会出问题 queryset = models.Car.objects.all() serializer_class = serializers.CarModelSerializer # 局部配置 过滤类 们（全局配置用DEFAULT_FILTER_BACKENDS） filter_backends = [LimitFilter] 过滤器插件 django-filter urls.py from django.urls import path from . import views urlpatterns = [ path(\u0026#39;cars4/\u0026#39;, views.CarListAPIView4.as_view()), # 插件django-filter ] filters.py # django-fitler插件：自定义过滤字段 from django_filters import filters from django_filters.rest_framework.filterset import FilterSet from django.db.models import Q class CarFilterSet(FilterSet): min_price = filters.NumberFilter(field_name=\u0026#39;price\u0026#39;, lookup_expr=\u0026#39;gte\u0026#39;) max_price = filters.NumberFilter(field_name=\u0026#39;price\u0026#39;, lookup_expr=\u0026#39;lte\u0026#39;) top_category = django_filters.NumberFilter(method=\u0026#39;top_category_filter\u0026#39;) def top_category_filter(self, queryset, name, value): return queryset.filter(Q(category_id=value)|Q(category__parent_category_id=value)|Q(category__parent_category__parent_category_id=value)) class Meta: model = models.Car fields = [\u0026#39;brand\u0026#39;, \u0026#39;min_price\u0026#39;, \u0026#39;max_price\u0026#39;] # brand是model中存在的字段，一般都是可以用于分组的字段 # min_price、max_price是自定义字段，需要自己自定义过滤条件 views.py # django-filter插件过滤器 from django_filters.rest_framework import DjangoFilterBackend from .filters import CarFilterSet class CarListAPIView4(ListAPIView): queryset = models.Car.objects.all() serializer_class = serializers.CarModelSerializer # 局部配置 过滤类 们（全局配置用DEFAULT_FILTER_BACKENDS） filter_backends = [DjangoFilterBackend] # django-filter过滤器插件使用 #filter_class = CarFilterSet filterset_class = CarFilterSet # 旧版写作filter_class, 新版写作fitlerset_class # 接口：?brand=...\u0026amp;min_price=...\u0026amp;max_price=... # eg:?brand=宝马\u0026amp;min_price=5\u0026amp;max_price=10 =\u0026gt; 5~10间的宝马牌汽车 ","permalink":"https://chenzqi.cn/posts/2020/20200622_drf%E8%BF%87%E6%BB%A4%E5%99%A8%E7%BB%84%E4%BB%B6/","tags":["框架","Django","DRF"],"title":"DRF 过滤器组件"},{"categories":[2020,"技术"],"contents":":::tip Django REST Framework. Generic Views, MixIns, ViewSets and Routers ::: 基本信息 源码仓库 rest_framework.views rest_framework.generics rest_framework.viewsets rest_framework.routers 官方文档 API Guide-Generic views API Guide-ViewSets API Guide-Routers 关系图 ::: details View继承图与View图谱 ::: AIPView-API视图类 APIView 是 Django REST Framework 提供的所有视图的基类，继承自 Django 的 View 父类 AIPView 对比 Django View 传入到视图方法中的是 REST framework 的 Request 对象，而不是 Django 的 HttpRequeset 对象 视图方法可以返回 REST framework 的 Response 对象，视图会为响应数据设置（render）符合前端要求的格式 任何 APIException 异常都会被捕获到，并且处理成合适的响应信息 在进行 dispatch() 分发前，会对请求进行身份认证、权限检查、流量控制 重要类属性 AIPView 有如下可设置的重要类属性： authentication_classes：列表或元祖，身份认证类 permissoin_classes： 列表或元祖，权限检查类 throttle_classes： 列表或元祖，流量控制类 示例 views.py from rest_framework.views import APIView from rest_framework.response import Response from models import Goods from serializers import GoodsSerializer class GoodListView(APIView): def get(self, request): goods = Goods.objects.all() serializer = GoodsSerializer(goods, many=True) return Response(serializer.data) serializers.py class GoodsSerializer(serializers.ModelSerializer): # category = CategorySerializer() # images = GoodsImageSerializer(many=True) class Meta: model = Goods fields = \u0026#34;__all__\u0026#34; GenericAPIView-通用API视图类 通用 API 视图类 GenericAPIView 继承自 APIView，完全兼容 APIView，主要增加了操作序列化器和数据库查询的方法，作用是为下面 Mixin 扩展类的执行提供基础类支持。通常在使用时，可以配合一个或多个 Mixin 扩展类。 GenericAPIView 对比 APIView get_queryset()： 从类属性 queryset中获得 model 的 queryset 数据。群操作就走 get_queryset() 方法 (包括群查，群增等)。 get_object()： 从类属性 queryset 中获得 model 的 queryset 数据，再通过有名分组 pk 确定唯一操作对象。单操作就走 get_object() 方法（包括单查，单增等）。 get_serializer()：从类属性 serializer_class 中获得 serializer 的序列化类。 重要类属性 列表视图与详情视图共用 queryset： 指明视图需要的数据（model 查询数据） permissoin_classes：指明视图使用的序列化器 列表视图使用 pagination_class：指定分页控制类 filter_backends： 指定过滤控制后端 详情页视图使用 lookup_field： 自定义主键，有名分组的查询，默认是 pk lookup_url_kwarg：查询单一数据时 url 中的参数关键字名称，默认与 look_field 相同 重要类方法 get_queryset()： 从类属性 queryset 中获得 model 的 queryset 数据　get_object()： 从类属性 queryset 中获得 model 的 queryset 数据，再通过有名分组 pk 来确定唯一操作对象 get_serializer()：从类属性 serializer_class 中获得 serializer 的序列化类，主要用来提供给 Mixin 扩展类使用 get_serializer 源码 def get_serializer(self, *args, **kwargs): \u0026#34;\u0026#34;\u0026#34; Return the serializer instance that should be used for validating and deserializing input, and for serializing output. 返回应该用于验证和反序列化输入以及序列化输出的序列化器实例。 \u0026#34;\u0026#34;\u0026#34; serializer_class = self.get_serializer_class() kwargs[\u0026#39;context\u0026#39;] = self.get_serializer_context() return serializer_class(*args, **kwargs) 示例 views.py class GoodGenericAPIView(GenericAPIView): queryset = models.Good.objects.filter(is_delete=False) serializer_class = serializers.GoodModelSerializer lookup_field = \u0026#39;pk\u0026#39; # 先定义好，单查可以使用，默认是pk 自定义主键的有名分组，如果路由有名分组不是pk,这个属性就要自己设置了 # 群取 def get(self, request, *args, **kwargs): good_query = self.get_queryset() # 获取queryset数据（model查询数据） good_ser = self.get_serializer(good_query, many=True) good_data = good_ser.data return APIResponse(results=good_data) # # 单取 # def get(self, request, *args, **kwargs): # good_query = self.get_object() # good_ser = self.get_serializer(good_query) # good_data = good_ser.data # return APIResponse(results=good_data) urls.py urlpatterns = [ path(\u0026#39;v2/goods/\u0026#39;, views.GoodGenericAPIView.as_view()), path(\u0026#39;v2/goods/\u0026lt;pk\u0026gt;/\u0026#39;, views.GoodGenericAPIView.as_view()), ] xxxModelMixin-视图类的模型工具集 作用 提供了几种后端视图（对数据资源的增删改查）处理流程的实现，如果需要编写的视图属于这五种，则视图可以通过继承相应的扩展类来复用代码，减少自己编写的代码量。 mixins 有五个工具类文件，一共提供了五个工具类，六个工具方法：单查、群查、单增、单删、单整体改、单局部改 使用 继承工具类可以简化请求函数的实现体，但是必须继承 GenericAPIView，需要 GenericAPIView 类提供序列化器与数据库查询的方法 (见上方 GenericAPIView 基类知识点) 工具类的工具方法返回值都是 Response 类型对象，如果要格式化数据格式再返回给前台，可以通过 response.data 拿到工具方法返回的 Response 类型对象的响应数据 五大模型工具类 ListModelMixin 群查 列表视图扩展类，提供 list 方法快速实现查询视图 返回 200 状态码 除了查询，该 list 方法会对数据进行过滤和分页 CreateModelMixin 单增 创建视图扩展类，提供 create 方法快速创建资源的视图，成功返回 201 的状态码 没有群增的方法，需要自己手动写 RetrieveModelMixin 单查 详情视图扩展类，提供 retrieve 方法，可以快速实现返回一个存在的数据对象 UpdateModelMixin 更新 / 修改 更新视图扩展类，提供 update 方法，可以快速实现更新一个存在的数据对象，同时也提供 partial_update 方法，可以实现局部更新 只有单整体改和单局部改，没有群整体改和群局部改 DestoryModelMixin 删除 删除视图扩展类，提供 destory 方法，可以快速实现删除一个存在数据对象 一般不怎么用到，因为实际开发中并不会真的删除数据，而是修改是否可用的标记 示例 views.py from rest_framework.mixins import ListModelMixin, CreateModelMixin, RetrieveModelMixin, UpdateModelMixin class GoodMixinGenericAPIView(ListModelMixin, CreateModelMixin, RetrieveModelMixin, UpdateModelMixin, GenericAPIView): # GenericAPIView提供的序列化器和查询的数据 queryset = models.Good.objects.filter(is_delete=False) serializer_class = serializers.GoodModelSerializer # 单查和群查 def get(self, request, *args, **kwargs): if \u0026#39;pk\u0026#39; in kwargs: # 单查 RetrieveModelMixin方法 response = self.retrieve(request, *args, **kwargs) else: # mixins提供的list方法的响应对象是Response，将该对象格式化为自定义的APIResponse response = self.list(request, *args, **kwargs) # 群查 ListModelMixin # response的数据都存放在response.data中 return APIResponse(results=response.data) # 单增 def post(self, request, *args, **kwargs): response = self.create(request, *args, **kwargs) # CreateModelMixin方法 return APIResponse(results=response.data) # 单整体修改 def put(self, request, *args, **kwargs): response = self.update(request, *args, **kwargs) # UpdateModelMixin return APIResponse(results=response.data) # 单局部修改 def patch(self, request, *args, **kwargs): response = self.partial_update(request, *args, **kwargs) return APIResponse(results=response.data) urls.py urlpatterns = [ path(\u0026#39;v3/goods/\u0026#39;, views.GoodMixinGenericAPIView.as_view()), path(\u0026#39;v3/goods/\u0026lt;pk\u0026gt;/\u0026#39;, views.GoodMixinGenericAPIView.as_view()), ] xxxAPIView-功能性子视图类 功能性子视图类继承了 GenericAPIView 和各种 Mixins 工具类 功能性视图类都是 GenericAPIView 的子类，且不同的子类继承了不同的工具类 功能性视图类的功能可以满足需求，只需要继承工具视图，并且提供 queryset 与 serializer_class 即可 各大功能子视图类 视图 作用 请求类型 父类 ListAPIView 查询多条数据 get GenericAPIView ListModelMixin CreateAPIView 新增一条数据 post GenericAPIView CreateModelMixin RetrieveAPIView 查询一条数据 get GenericAPIView RetrieveModelMixin UpdateAPIView 修改一条数据 put patch GenericAPIView UpdateModelMixin DestroyAPIView 删除一条数据 delete GenericAPIView DestroyModelMixin RetrieveUpdateAPIView 单查 更新一条 get put patch GenericAPIView RetrieveModelMixin UpdateModelMixin RetrieveUpdateDestroyAPIView 单查 更新删除一条 get put patch delete GenericAPIView RetrieveModelMixin UpdateModelMixin DestroyModelMixin ListCreateAPIView 群查 更新一条 get post GenericAPIView ListModelMixin mixins.CreateModelMixin xxxViewset-视图集 常用视图集父类 ViewSetMixin ViewSetMixin 主要是自定义了 as_view 方法，使可以通过其参数指定 HTTP_METHOD 与函数的映射关系，如 view = MyViewSet.as_view({\u0026lsquo;get\u0026rsquo;: \u0026rsquo;list\u0026rsquo;, \u0026lsquo;post\u0026rsquo;: \u0026lsquo;create\u0026rsquo;}) ViewSet 继承自 APIView 和 ViewSetMixin，没有提供任何方法，需要自己写 GenericViewSet 继承 GenericAPIView 和 ViewSetMixin，其中 GenericAPIView 提供了基础方法，可以直接搭配 Mixin 扩展类使用，因此比较常用 ModelViewSet　继承 GenericViewset，但同时也包括 ListModelMixin、CreateModelMixin 等 mixin 扩展类 源码分析 视图集都是默认优先继承 ViewSetMixin 类，再继承一个视图类（GenericAPIView 或 APIView） ViewSetMixin 提供了重写的 as_view() 方法，继承视图集的视图类，配置路由时调用 as_view() 必须传入 请求名 - 函数名 映射关系字典 例如: # 表示 get 请求会交给 my_get_list 视图函数处理 path(\u0026#39;v5/books/\u0026#39;, views.BookGenericViewSet.as_view({\u0026#39;get\u0026#39;: \u0026#39;my_get_list\u0026#39;})), GenericViewSet 示例代码 urls.py urlpatterns = [ # View的as_view()：将get请求映射到视图类的get方法 # ViewSet的as_view({\u0026#39;get\u0026#39;: \u0026#39;my_get_list\u0026#39;})：将get请求映射到视图类的my_get_list方法 path(\u0026#39;v5/books/\u0026#39;, views.BookGenericViewSet.as_view({\u0026#39;get\u0026#39;: \u0026#39;my_get_list\u0026#39;})), path(\u0026#39;v5/books/\u0026lt;pk\u0026gt;/\u0026#39;, views.BookGenericViewSet.as_view({\u0026#39;get\u0026#39;: \u0026#39;my_get_obj\u0026#39;})), ] views.py from rest_framework.viewsets import GenericViewSet from rest_framework import mixins #工具集 可以使用list, retrieve等方法 class BookGenericViewSet(RetrieveModelMixin, ListModelMixin, GenericViewSet): queryset = models.Book.objects.filter(is_delete=False) serializer_class = serializers.BookModelSerializer def my_get_list(self, request, *args, **kwargs): return self.list(request, *args, **kwargs) def my_get_obj(self, request, *args, **kwargs): return self.retrieve(request, *args, **kwargs) GenericViewSet 与 ViewSet 异同 GenericViewSet 和 ViewSet 都继承了 ViewSetMixin，as_view 都可以配置 请求 - 函数 映射 GenericViewSet 继承的是 GenericAPIView 视图类，用来完成标准的 model 类操作接口 ViewSet 继承的是 APIView 视图类，用来完成不需要 model 类参与，或是非标准的 model 类操作接口，如 post 请求在标准的 model 类操作下就是新增接口，登陆的 post 不满足。登陆的 post 请求，并不是完成数据的新增，只是用 post 提交数据，得到的结果也不是登陆的用户信息，而是登陆的认证信息 post 请求验证码的接口，不需要 model 类的参与 源码 GenericViewSet # viewsets.py class GenericViewSet(ViewSetMixin, generics.GenericAPIView): \u0026#34;\u0026#34;\u0026#34; The GenericViewSet class does not provide any actions by default, but does include the base set of generic view behavior, such as the `get_object` and `get_queryset` methods. 默认情况下，GenericViewSet类不提供任何操作，但是包含通用视图行为的基本集，比如get ohiect和get queryset方法 \u0026#34;\u0026#34;\u0026#34; pass # generics.py class GenericAPIView(views.APIView): # ... # vies.py class APIView(View): # ... ViewSet class ViewSet(ViewSetMixin, views.APIView): \u0026#34;\u0026#34;\u0026#34; The base ViewSet class does not provide any actions by default. 默认情况下，基本ViewSet类不提供任何操作。 \u0026#34;\u0026#34;\u0026#34; pass # vies.py class APIView(View): # ... ModelViewSet 示例代码 urls.py urlpatterns = [ path(\u0026#39;v6/books/\u0026#39;, views.BookModelViewSet.as_view({\u0026#39;get\u0026#39;: \u0026#39;list\u0026#39;, \u0026#39;post\u0026#39;: \u0026#39;create\u0026#39;})), path(\u0026#39;v6/books/\u0026lt;pk\u0026gt;/\u0026#39;, views.BookModelViewSet.as_view({\u0026#39;get\u0026#39;: \u0026#39;retrieve\u0026#39;, \u0026#39;put\u0026#39;: \u0026#39;update\u0026#39;, \u0026#39;patch\u0026#39;: \u0026#39;partial_update\u0026#39;, \u0026#39;delete\u0026#39;: \u0026#39;destroy\u0026#39;})), ] views.py class BookModelViewSet(ModelViewSet): queryset = models.Book.objects.filter(is_delete=False) serializer_class = serializers.BookModelSerializer # 删不是数据库，而是该记录中的修改is_delete的值，因此重写默认的destroy函数 def destroy(self, request, *args, **kwargs): instance = self.get_object() # type: models.Book if not instance: return APIResponse(1, \u0026#39;删除失败\u0026#39;) # 实际操作，在此之前就做了判断 instance.is_delete = True instance.save() return APIResponse(0, \u0026#39;删除成功\u0026#39;) 路由组件 因为具有局限性，所以在开发复杂接口时并不是首选。 示例代码如下： from django.urls import path, include from rest_framework.routers import SimpleRouter from . import views router = SimpleRouter() # 所有路由与ViewSet视图类的都可以注册，会产生 \u0026#39;v7/books/\u0026#39; 和 \u0026#39;v7/books/\u0026lt;pk\u0026gt;/\u0026#39; router.register(\u0026#39;v7/books\u0026#39;, views.BookModelViewSet) urlpatterns = [ # router.urls 添加方法一 # path(\u0026#39;\u0026#39;, include(router.urls)), ] # router.urls 添加方法二 # urlpatterns += router.urls ","permalink":"https://chenzqi.cn/posts/2020/20200621_drf%E9%80%9A%E7%94%A8%E8%A7%86%E5%9B%BE-%E8%A7%86%E5%9B%BE%E5%B7%A5%E5%85%B7%E7%B1%BB-%E8%A7%86%E5%9B%BE%E9%9B%86%E4%BB%A5%E5%8F%8A%E8%B7%AF%E7%94%B1/","tags":["框架","Django","DRF"],"title":"DRF 通用视图-视图工具类-视图集以及路由"},{"categories":[2020,"技术"],"contents":":::tip Vue + Element-UI 搭建后台管理系统模型 ::: 线上测试地址 ","permalink":"https://chenzqi.cn/posts/2020/20200613_vue%E6%90%AD%E5%BB%BA%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/","tags":["前端"],"title":"VUE搭建后台管理系统"},{"categories":[2020,"技术"],"contents":"关闭某个端口 firewall-cmd --permanent --zone=public --remove-port=8080/tcp 打开某个端口 firewall-cmd --permanent --add-port=10086/tcp 重新加载防火墙策略 firewall-cmd --reload 查看防火墙端口开放情况 firewall-cmd --list-ports ","permalink":"https://chenzqi.cn/posts/2020/20200606_linux%E9%98%B2%E7%81%AB%E5%A2%99%E7%AB%AF%E5%8F%A3%E8%AE%BE%E7%BD%AE/","tags":["记录","linux"],"title":"linux防火墙端口设置"},{"categories":[2020,"技术"],"contents":":::tip Flask SQLAlchemy字段默认值参数 server_default 与 default 区别 ::: defult 这种方法不会在数据库里面设置默认值，是使用了SQLAlchemy Model类提交数据时添加上去的值，不适合需要取数据库所有服务器时间的场合。 from sqlalchemy.sql.sqltypes import TIMESTAMP class Test(db.Model): id = db.Column(db.Integer, primary_key = True) name = db.Column(db.String(32)) create_date = db.Column(TIMESTAMP, default = datetime.datetime) server_default 使用 SQLAlchemy 模型直接在数据库设置默认值的方法： ::: warning 需要注意的 ? Integer 默认值不能直接设置数字，需要是字符串； DateTime 默认值需要使用func.now()； 自动更新的时间戳可以使用TIMESTAMP，只需设置nullable=False即可 ::: #mysql 日期设置默认值必须使用timestamp类型 from sqlalchemy.sql.sqltypes import TIMESTAMP #func用来生成数据库函数代码，跟踪进源代码看一*** from sqlalchemy.sql import func class Test(db.Model): id = db.Column(db.Integer, primary_key = True) name = db.Column(db.String(32)) create_date = db.Column(TIMESTAMP, server_default = func.now()) # 注意这里是 server_default ","permalink":"https://chenzqi.cn/posts/2020/20200529_sqlalchemy%E5%AD%97%E6%AE%B5%E9%BB%98%E8%AE%A4%E5%80%BC/","tags":["记录","flask"],"title":"SQLAlchemy字段默认值"},{"categories":[2020,"技术"],"contents":":::tip 后端常用响应码 ::: \u0026#34;\u0026#34;\u0026#34;共用的一些数字约定含义\u0026#34;\u0026#34;\u0026#34; class RET: OK = \u0026#34;0\u0026#34; DBERR = \u0026#34;4001\u0026#34; NODATA = \u0026#34;4002\u0026#34; DATAEXIST = \u0026#34;4003\u0026#34; DATAERR = \u0026#34;4004\u0026#34; SESSIONERR = \u0026#34;4101\u0026#34; LOGINERR = \u0026#34;4102\u0026#34; PARAMERR = \u0026#34;4103\u0026#34; USERERR = \u0026#34;4104\u0026#34; ROLEERR = \u0026#34;4105\u0026#34; PWDERR = \u0026#34;4106\u0026#34; REQERR = \u0026#34;4201\u0026#34; IPERR = \u0026#34;4202\u0026#34; THIRDERR = \u0026#34;4301\u0026#34; IOERR = \u0026#34;4302\u0026#34; SERVERERR = \u0026#34;4500\u0026#34; UNKOWNERR = \u0026#34;4501\u0026#34; error_map = { RET.OK : \u0026#34;成功\u0026#34;, RET.DBERR : \u0026#34;数据库查询错误\u0026#34;, RET.NODATA : \u0026#34;无数据\u0026#34;, RET.DATAEXIST : \u0026#34;数据已存在\u0026#34;, RET.DATAERR : \u0026#34;数据错误\u0026#34;, RET.SESSIONERR : \u0026#34;用户未登录\u0026#34;, RET.LOGINERR : \u0026#34;用户登录失败\u0026#34;, RET.PARAMERR : \u0026#34;参数错误\u0026#34;, RET.USERERR : \u0026#34;用户不存在或未激活\u0026#34;, RET.ROLEERR : \u0026#34;用户身份错误\u0026#34;, RET.PWDERR : \u0026#34;密码错误\u0026#34;, RET.REQERR : \u0026#34;非法请求或请求次数受限\u0026#34;, RET.IPERR : \u0026#34;IP受限\u0026#34;, RET.THIRDERR : \u0026#34;第三方系统错误\u0026#34;, RET.IOERR : \u0026#34;文件读写错误\u0026#34;, RET.SERVERERR : \u0026#34;内部错误\u0026#34;, RET.UNKOWNERR : \u0026#34;未知错误\u0026#34;, } ","permalink":"https://chenzqi.cn/posts/2020/20200529_%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B8%B8%E7%94%A8%E5%90%8E%E7%AB%AF%E5%93%8D%E5%BA%94%E7%A0%81/","tags":["web"],"title":"自定义常用后端响应码"},{"categories":[2020,"技术"],"contents":":::tip PyQt5安装与Qt Designer，PyUIC在 PyCharm 中配置 ::: PyQt5,Qt Designer安装 pip install sip pip install PyQt5 pip install PyQt5-tools 安装完成后，在python安装目录下可以看到下面标出的文件夹 配置PyCharm ::: details 为什么配置PyCharm? 配置PyCharm是为了在 Pycharm 里面实现打开 Qt Designer ，生成qt文件，方便转换成 python 文件. ::: 打开Pycharm，settings 按下图操作 Name：可自己定义 Program：指向上述安装PyQt5-tools里面的designer.exe Work directory：使用变量 $FileDir$ 再新建一个“PyUIC”，这个主要是用来将 Qt 界面 转换成 py 代码 Arguments的值改成下: -m PyQt5.uic.pyuic $FileName$ -o $FileNameWithoutExtension$.py 使用 打开Qt Designer进行UI编辑 设计UI 保存后会在当前文件夹生成ui后缀的文件，点击ui文件右键 External Tool 》 PyUIC，会自动生成python文件，做一些编辑才能运行。两种方案： 直接在当前文件添加以下代码 import sys from PyQt5.QtWidgets import QApplication, QMainWindow ... ... if __name__ == \u0026#39;__main__\u0026#39;: app = QApplication(sys.argv) MainWindow = QMainWindow() ui = Ui_MainWindow() ui.setupUi(MainWindow) MainWindow.show() sys.exit(app.exec_()) 新建启动文件（方便逻辑层编写） ","permalink":"https://chenzqi.cn/posts/2020/20200526_pyqt5%E5%AE%89%E8%A3%85%E4%B8%8Epycharm%E9%85%8D%E7%BD%AE/","tags":["工具","配置"],"title":"PyQt5安装与PyCharm配置"},{"categories":[2020,"技术"],"contents":":::tip 微信小程序登录API实现 ::: 小程序登录流程 小程序端调用 wx.login 判断用户是否授权 小程序端访问 wx.getUserInfo 小程序端js代码 wx.login({ success: resp =\u0026gt; { // 发送 res.code 到后台换取 openId, sessionKey, unionId console.log(resp); var that = this; // 获取用户信息 wx.getSetting({ success: res =\u0026gt; { if (res.authSetting[\u0026#39;scope.userInfo\u0026#39;]) { // 已经授权，可以直接调用 getUserInfo 获取头像昵称，不会弹框 wx.getUserInfo({ success: userResult =\u0026gt; { var platUserInfoMap = {} platUserInfoMap[\u0026#34;encryptedData\u0026#34;] = userResult.encryptedData; platUserInfoMap[\u0026#34;iv\u0026#34;] = userResult.iv; wx.request({ url: \u0026#39;http://127.0.0.1:5000/user/wxlogin\u0026#39;, data: { platCode: resp.code, platUserInfoMap: platUserInfoMap, }, header: { \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34; }, method: \u0026#39;POST\u0026#39;, dataType:\u0026#39;json\u0026#39;, success: function (res) { console.log(res) wx.setStorageSync(\u0026#34;userinfo\u0026#34;, res.userinfo) //设置本地缓存 }, fail: function (err) { },//请求失败 complete: function () { }//请求完成后执行的函数 }) } }) } } }) } }) 后端服务器访问 code2session，通过 code2Session 这个api接口来获取真正需要的微信用户的登录态 session_ke y和 openid 和 unionid. 后端服务器校验用户信息，对 encryptedData 解密 微信小程序登录后获得 session_key 后，返回了encryptedData，iv 的数据，其中 encryptedData 解密后包含了用户的信息，解密后的json格式如下： { \u0026#34;openId\u0026#34;: \u0026#34;OPENID\u0026#34;, \u0026#34;nickName\u0026#34;: \u0026#34;NICKNAME\u0026#34;, \u0026#34;gender\u0026#34;: GENDER, \u0026#34;city\u0026#34;: \u0026#34;CITY\u0026#34;, \u0026#34;province\u0026#34;: \u0026#34;PROVINCE\u0026#34;, \u0026#34;country\u0026#34;: \u0026#34;COUNTRY\u0026#34;, \u0026#34;avatarUrl\u0026#34;: \u0026#34;AVATARURL\u0026#34;, \u0026#34;unionId\u0026#34;: \u0026#34;UNIONID\u0026#34;, \u0026#34;watermark\u0026#34;: { \u0026#34;appid\u0026#34;:\u0026#34;APPID\u0026#34;, \u0026#34;timestamp\u0026#34;:TIMESTAMP } } 解密文件 —— WXBizDataCrypt.py import base64 import json from Crypto.Cipher import AES class WXBizDataCrypt: def __init__(self, appId, sessionKey): self.appId = appId self.sessionKey = sessionKey def decrypt(self, encryptedData, iv): # base64 decode sessionKey = base64.b64decode(self.sessionKey) encryptedData = base64.b64decode(encryptedData) iv = base64.b64decode(iv) cipher = AES.new(sessionKey, AES.MODE_CBC, iv) decrypted = json.loads(self._unpad(cipher.decrypt(encryptedData))) if decrypted[\u0026#39;watermark\u0026#39;][\u0026#39;appid\u0026#39;] != self.appId: raise Exception(\u0026#39;Invalid Buffer\u0026#39;) return decrypted def _unpad(self, s): return s[:-ord(s[len(s)-1:])] Flask 的 wxlogin API import json, requests from WXBizDataCrypt import WXBizDataCrypt from flask import Flask, jsonify @app.route(\u0026#39;/user/wxlogin\u0026#39;, methods=[\u0026#39;GET\u0026#39;,\u0026#39;POST\u0026#39;]) def user_wxlogin(): appID = \u0026#39;appID\u0026#39; # 开发者关于微信小程序的appID appSecret = \u0026#39;appSecret\u0026#39; # 开发者关于微信小程序的appSecret data = json.loads(request.get_data().decode(\u0026#39;utf-8\u0026#39;)) # 将前端Json数据转为字典 code = data[\u0026#39;platCode\u0026#39;] # 前端POST过来的微信临时登录凭证code encryptedData = data[\u0026#39;platUserInfoMap\u0026#39;][\u0026#39;encryptedData\u0026#39;] iv = data[\u0026#39;platUserInfoMap\u0026#39;][\u0026#39;iv\u0026#39;] req_params = { \u0026#39;appid\u0026#39;: appID, \u0026#39;secret\u0026#39;: appSecret, \u0026#39;js_code\u0026#39;: code, \u0026#39;grant_type\u0026#39;: \u0026#39;authorization_code\u0026#39; } wx_login_api = \u0026#39;https://api.weixin.qq.com/sns/jscode2session\u0026#39; response_data = requests.get(wx_login_api, params=req_params) # 向API发起GET请求 resData = response_data.json() openid = resData[\u0026#39;openid\u0026#39;] # 得到用户关于当前小程序的OpenID session_key = resData[\u0026#39;session_key\u0026#39;] # 得到用户关于当前小程序的会话密钥session_key pc = WXBizDataCrypt(appID, session_key) #对用户信息进行解密 data = pc.decrypt(encryptedData, iv) #获得用户信息 print(userinfo) \u0026#39;\u0026#39;\u0026#39; 通过判断数据库中用户是否存在来确定添加或返回自定义登录态 若用户不存在则添加；若用户存在，返回用户信息） 数据库中对用户进行操作 \u0026#39;\u0026#39;\u0026#39; return jsonify(code=200, msg=\u0026#34;登录成功\u0026#34;, data=data) ","permalink":"https://chenzqi.cn/posts/2020/20200523_%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%99%BB%E5%BD%95/","tags":["web"],"title":"微信小程序登录详解及Flask API实现"},{"categories":[2020,"技术"],"contents":"多种实现方案: 开启多个命令行，分别执行scrapy cralw xxxx 编写脚本，执行工程下的所有爬虫 #!/usr/bin/env python # -*- coding:utf-8 -*- \u0026#34;\u0026#34;\u0026#34; @file: run.py @time: 2020/05/19 9:49 @desc: None @Author: Chenzq @Wechat: * @contact: czq181020@gmail.com \u0026#34;\u0026#34;\u0026#34; from scrapy.utils.project import get_project_settings from scrapy.crawler import CrawlerProcess def main(): setting = get_project_settings() process = CrawlerProcess(setting) didntWorkSpider = [\u0026#39;tb\u0026#39;, \u0026#39;jd\u0026#39;, \u0026#39;anjuke\u0026#39;, \u0026#39;51paimaifang\u0026#39;, \u0026#39;manjuke\u0026#39;, \u0026#39;upd_status\u0026#39;] print(didntWorkSpider) for spider_name in process.spiders.list(): if spider_name in didntWorkSpider: continue print(\u0026#34;Running spider %s\u0026#34; % (spider_name)) process.crawl(spider_name) process.start() main() 脚本解析： 正常情况下，在终端可以通过scrapy crawl *** 来运行某个 spider。 过程大致是，首先读取配置，其中 SpiderLoader 会默认读取配置文件中的 SPIDER_MODULES 对应的所有spider，另外还需要初始化各种类，其中包含了 CrawlerProcess 这个重要的类 cmd.crawler_process = CrawlerProcess(settings)，然后调用 crawl scrapy.commands.crawl, 这个终端命令 run 方法的具体实现，该实现中self.crawler_process.crawl(spname, **opts.spargs)，self.crawler_process.start() 使用scrapyd，部署爬虫，通过scrapyd的API调用爬虫 推荐使用 spiderkeeper或者 gerapy，spiderkeeper可以定时运行爬虫。 ","permalink":"https://chenzqi.cn/posts/2020/20200519_scrapy%E5%90%8C%E6%97%B6%E8%BF%90%E8%A1%8C%E5%A4%9A%E4%B8%AA%E7%88%AC%E8%99%AB/","tags":["爬虫","框架","scrapy"],"title":"Scrapy同时运行多个爬虫"},{"categories":[2020,"技术"],"contents":":::tip 安居客网页价格字体加密问题 ::: 问题 由js生成的fangchan-secret自定义字体，每隔几秒钟变化fangchan-secret的key。 解决 根据网址获得的fangchan-secret的key来解码 bs64_str是网页内容正则匹配到的key: bs64_str = re.findall(\u0026#34;charset=utf-8;base64,(.*?)\u0026#39;\\)\u0026#34;, html_str)[0] from io import BytesIO from fontTools.ttLib import TTFont import base64 def get_page_show_ret(mystr, bs64_str): \u0026#39;\u0026#39;\u0026#39; :param mystr: 要转码的字符串 :param bs64_str: 转码格式 :return: 转码后的字符串 \u0026#39;\u0026#39;\u0026#39; font = TTFont(BytesIO(base64.decodebytes(bs64_str.encode()))) c = font[\u0026#39;cmap\u0026#39;].tables[0].ttFont.tables[\u0026#39;cmap\u0026#39;].tables[0].cmap ret_list = [] for char in mystr: decode_num = ord(char) if decode_num in c: num = c[decode_num] num = int(num[-2:]) - 1 ret_list.append(num) else: ret_list.append(char) ret_str_show = \u0026#39;\u0026#39; for num in ret_list: ret_str_show += str(num) return ret_str_show ","permalink":"https://chenzqi.cn/posts/2020/20200516_%E5%AE%89%E5%B1%85%E5%AE%A2%E5%AD%97%E4%BD%93%E8%A7%A3%E5%AF%86/","tags":["爬虫","解密"],"title":"安居客字体解密"},{"categories":[2020,"技术"],"contents":":::tip scrapy中间件重构 ::: 官方文档：Downloader Middleware 重写 import json # 处理json的包 import redis # Python操作redis的包 import random # 随机选择 from .useragent import agents # 导入请求头列表 from scrapy.downloadermiddlewares.useragent import UserAgentMiddleware # UserAegent中间件 from scrapy.downloadermiddlewares.retry import RetryMiddleware # 重试中间件 class UserAgentmiddleware(UserAgentMiddleware): def process_request(self, request, spider): agent = random.choice(agents) request.headers[\u0026#34;User-Agent\u0026#34;] = agent 定义了一个类 UserAgentmiddleware 继承自 UserAgentMiddleware 。 定义了函数 process_request(request, spider) ，Scrapy 每一个 request 通过中间 件都会调用这个方法。 随机选择一个 User-Agent。 设置 request 的 User-Agent 为我们随机的 User-Agent。 Cookie 池 维护一个 Cookie 池 (redis)，备些功能： 获取 Cookie 更新 Cookie 删除 Cookie 判断 Cookie 是否可用进行相对应的操作（比如重试） 新建一个 cookies.py 的文件，导入需要的文件： import requests import json import redis import logging from .settings import REDIS_URL ##获取settings.py中的REDIS_URL 登陆用的账号密码 以 Key:value 的形式存入 redis 数据库。不推荐使用 db0（账号密码单独使用一个 db 进行存储） 获取 Cookie import requests import json import redis import logging from .settings import REDIS_URL logger = logging.getLogger(__name__) # 使用REDIS_URL链接Redis数据库, deconde_responses=True 这个参数必须要，数据会变成byte形式 完全没法用 reds = redis.Redis.from_url(REDIS_URL, db=2, decode_responses=True) login_url = \u0026#39;http://haoduofuli.pw/wp-login.php\u0026#39; # 获取Cookie def get_cookie(account, password): s = requests.Session() payload = { \u0026#39;log\u0026#39;: account, \u0026#39;pwd\u0026#39;: password, \u0026#39;rememberme\u0026#39;: \u0026#34;forever\u0026#34;, \u0026#39;wp-submit\u0026#39;: \u0026#34;登录\u0026#34;, \u0026#39;redirect_to\u0026#39;: \u0026#34;http://http://www.haoduofuli.pw/wp-admin/\u0026#34;, \u0026#39;testcookie\u0026#39;: \u0026#34;1\u0026#34; } response = s.post(login_url, data=payload) cookies = response.cookies.get_dict() logger.warning(\u0026#34;获取Cookie成功！（账号为:%s）\u0026#34; % account) return json.dumps(cookies) 使用 requests 模块提交表单登陆获得 Cookie，返回一个通过 Json 序列化后的 Cookie（如果不序列化，存入 Redis 后会变成 Plain Text 格式的，后面取出来 Cookie 就没法用） 将 Cookie 写入 Redis 数据库（其它 Spider 也能使用这个 Cookie ）: def init_cookie(red, spidername): redkeys = reds.keys() for user in redkeys: password = reds.get(user) if red.get(\u0026#34;%s:Cookies:%s--%s\u0026#34; % (spidername, user, password)) is None: cookie = get_cookie(user, password) red.set(\u0026#34;%s:Cookies:%s--%s\u0026#34;% (spidername, user, password), cookie) 重写 Cookie 中间件 class CookieMiddleware(RetryMiddleware): def __init__(self, settings, crawler): # 继承父类之后；子类是不能用 def init() 方法的，需要重载父类才可以用 RetryMiddleware.__init__(self, settings) self.rconn = redis.from_url(settings[\u0026#39;REDIS_URL\u0026#39;], db=1, decode_responses=True #decode_responses设置取出的编码为str # 往 redis 中添加 cookie init_cookie(self.rconn, crawler.spider.name) @classmethod def from_crawler(cls, crawler): return cls(crawler.settings, crawler) def process_request(self, request, spider): redisKeys = self.rconn.keys() while len(redisKeys) \u0026gt; 0: elem = random.choice(redisKeys) if spider.name + \u0026#39;:Cookies\u0026#39; in elem: cookie = json.loads(self.rconn.get(elem)) request.cookies = cookie request.meta[\u0026#34;accountText\u0026#34;] = elem.split(\u0026#34;Cookies:\u0026#34;)[-1] break 访问 settings 的方法官方文档：官方文档 完整代码 # -*- coding: utf-8 -*- # Define here the models for your spider middleware # # See documentation in: # http://doc.scrapy.org/en/latest/topics/spider-middleware.html from scrapy import signals import json import redis import random from .useragent import agents from .cookies import init_cookie, remove_cookie, update_cookie from scrapy.downloadermiddlewares.useragent import UserAgentMiddleware from scrapy.downloadermiddlewares.retry import RetryMiddleware import logging logger = logging.getLogger(__name__) class UserAgentmiddleware(UserAgentMiddleware): def process_request(self, request, spider): agent = random.choice(agents) request.headers[\u0026#34;User-Agent\u0026#34;] = agent class CookieMiddleware(RetryMiddleware): def __init__(self, settings, crawler): RetryMiddleware.__init__(self, settings) self.rconn = redis.from_url(settings[\u0026#39;REDIS_URL\u0026#39;], db=1, decode_responses=True) #decode_responses设置取出的编码为str init_cookie(self.rconn, crawler.spider.name) def from_crawler(cls, crawler): return cls(crawler.settings, crawler) def process_request(self, request, spider): redisKeys = self.rconn.keys() while len(redisKeys) \u0026gt; 0: elem = random.choice(redisKeys) if spider.name + \u0026#39;:Cookies\u0026#39; in elem: cookie = json.loads(self.rconn.get(elem)) request.cookies = cookie request.meta[\u0026#34;accountText\u0026#34;] = elem.split(\u0026#34;Cookies:\u0026#34;)[-1] break #else: #redisKeys.remove(elem) #def process_response(self, request, response, spider): # # \u0026#34;\u0026#34;\u0026#34; # 判断cookie是否失效 # 进行相应的操作，如更新cookie 删除不能用的账号 # \u0026#34;\u0026#34;\u0026#34; ","permalink":"https://chenzqi.cn/posts/2020/20200515_%E9%87%8D%E5%86%99scrapy%E4%B8%8B%E8%BD%BD%E4%B8%AD%E9%97%B4%E4%BB%B6/","tags":["爬虫","框架","scrapy"],"title":"重载Scrapy下载中间件及Cookie池"},{"categories":[2020,"技术"],"contents":":::tip 使用python执行JS代码 ::: 简介 对于简单的 JS 来说，可以通过 Python 代码，直接重写，轻轻松松的就能搞定。 而对于复的 JS 代码，由于代码过于复杂，重写太费时费力，且碰到对方更新就比较麻烦。所以，一般直接使用程序去调用 JS，在 Python 层面就只是获取一个运行结果，这样做相比于重写而言就方便多了。 通常来说碰到 JS　逆向网站时会有这两种情况： 简单 JS 破解：通过 Python 代码轻松实现。 复杂的 JS 破解：代码不容易重写，使用程序直接调用 JS 运行获取结果。 1 Base64 Base64 是我们再写爬虫过程中经常看到的一种编码方式. // 原字符 NightTeam // 编码之后的： TmlnaHRUZWFt // 原字符 aiyuechuang // 编码之后的： YWl5dWVjaHVhbmc= // 原字符 Python3 // 编码之后 UHl0aG9uMw== 第二个例子是 aiyuechuang 编码之后的结果，它的末尾有一个等号，Python3 编码之后末尾有两个等号，这个特征相对第一个就比较明显。一般看到尾号有两个等号时应该大概可以猜到这个就是 Base64 。 然后，直接解码看一看，如果没有什么特别的话，就可以使用 Python 进行重写. 2 MD5 MD5 在 Javascript 中并没有标准的库，一般我们都是使用开源库去操作。 通常看到 32 位的一个英文数字混合的字符串，应该马上就能想到时 md5 了，这两个操作的话，因为在 Python 中都有对应的库，分别是：Base64 和 hashlib。 import base64 str1 = b\u0026#39;aiyuechuang\u0026#39; str2 = base64.b64encode(str1) print(str2) str3 = base64.b64decode(\u0026#39;YWl5dWVjaHVhbmc=\u0026#39;) print(str3) 输出: b\u0026#39;YWl5dWVjaHVhbmc=\u0026#39; b\u0026#39;aiyuechuang\u0026#39; import hashlib data = \u0026#34;aiyuechuang\u0026#34; result = hashlib.md5(data.encode(encoding = \u0026#34;UTF-8\u0026#34;)).hexdigest() print(result) 输出： e55babec7f5d5cf7bac7872f0481bec1 3 Python 调用 JS Python 调用 JS 库的库。 PyV8 Js2Py PyExecJS PyminiRacer Selenium Pyppeteer 3.1 PyExecJS 诞生于 Ruby 中的库，后来被移植到了 Python 上 较新的文章一般都会说用它来执行 JS 代码 有多个引擎可选，但一般我们会选择使用 NodeJS 作为引擎来执行代码 3.2 PyExecJS 的使用 安装 JS 运行环境Node.js 注意：虽然 Windows 上有个系统自带的 JScript，可以用来作为 PyExecjs 的引擎，但是这个 JScript 很容易与其他的引擎有一个不一样的地方，容易踩到一些奇奇怪怪的坑。所以请大家务必要安装一个其他的引擎。比如说我们这里安装 Node.js 。 安装 PyExecJS pip install pyexecjs 检测运行环境 IPython 终端执行 In [1]: import execjs In [2]: execjs.get().name # 查看调用环境 Out[2]: \u0026#39;Node.js (V8)\u0026#39; execjs.get() # 查看调用的环境用此来看看我们的库能不能检测到 nodejs，如果不能的话那就需要手动设置。 # 长期使用 os.environ[\u0026#34;EXECJS_RUNTIME\u0026#34;]=\u0026#34;Node\u0026#34; # 临时使用 import execjs.runtime_names node=execjs.get(execjs.runtime_names.Node) 两种形式：一种是长期使用的，通过环境变量的形式，通过把环境变量改成大写的 EXECJS_RUNTIME 然后将其值赋值为 Node。 另一种的话，将它改成临时使用的一种方式，这种是直接使用 get，这种做法的话，在使用的时候就需要使用 node 变量了，不能直接导入 PyExecjs 来直接开始使用，相对麻烦一些 使用 from pprint import pprint import execjs import pathlib import os js_path = pathlib.Path(os.path.abspath(os.path.dirname(__file__))) js_path = js_path / \u0026#34;crypto.js\u0026#34; with js_path.open(\u0026#39;r\u0026#39;, encoding=\u0026#34;utf-8\u0026#34;) as f: script = f.read() c = \u0026#34;1234\u0026#34; # 传入python中的变量 add = (\u0026#39;\u0026#39;\u0026#39; aesEncrypt = function() { result={} var t = CryptoJS.MD5(\u0026#34;login.xxx.com\u0026#34;), i = CryptoJS.enc.Utf8.parse(t), r = CryptoJS.enc.Utf8.parse(\u0026#34;1234567812345678\u0026#34;), u = CryptoJS.AES.encrypt(\u0026#39;\u0026#39;\u0026#39; + \u0026#34;\u0026#39;{}\u0026#39;\u0026#34;.format(c) + \u0026#39;\u0026#39;\u0026#39;,i, { iv: r }); result.t=t.toString() result.i =i.toString() result.r =r.toString() result.u =u.toString() return result }; \u0026#39;\u0026#39;\u0026#39;) script = script + add print(\u0026#34;script\u0026#34;,script) x = execjs.compile(script) result = x.call(\u0026#34;aesEncrypt\u0026#34;) print(result) 实际使用时，如果需要在 Python 中拿到 object 的话，建议把它转换成一个 json 字符串，而不是直接的把结果 return 出来。 因为，有些时候 PyExecjs 对 object 的转换会出现问题，所以可能会拿到一些类似于将字典直接用 str 函数包裹后转为字符串的一个东西，这样的话它是无法通过正常的方式去解析的 PyExecJS 存在的一些问题主要有以下两点： 执行大型 JS 时会有点慢（这个是因为，每次执行 JS 代码的时候，都是从命令行去调用到的 JS，所以 JS 代码越复杂的话，nodejs 的初始化时间就越长，这个基本上是无解的） 特殊编码的输入或输出参数会出现报错的情况（因为，是从命令行调用的，所以在碰到一些特殊字符输入或输出参数或者 JS 代码本身就有一些特殊字符的情况下，就会直接执行不了，给你抛出一个异常。不过这个跟系统的命令行默认编码有一定关系，具体的话这里就不深究了，直接就说解决方案吧。） 可以把输入或输出的参数使用 Base64 编码一下（如果看报错是 JS 代码部分导致的，那就去看看能不能删除代码中的那部分字符或者你自己 new 一个上下文对象，将那个名叫 tempfile 的参数打开，这样在调用的时候，它就直接去执行那个文件了，不过大量调用的情况下，可能会对磁盘造成一定压力。 而如果参数不充分导致的话，有个很简单的方法：就是把参数使用 Base64 编码一下，因为编码之后出来的字符串，我们知道 Base64 编码之后是生成英文和数字组成的。这样就没有特殊符号了。所以就不会出现问题了。） ","permalink":"https://chenzqi.cn/posts/2020/20200511_js-%E9%80%86%E5%90%91-python-%E8%B0%83%E7%94%A8js%E4%BB%A3%E7%A0%81/","tags":["python","爬虫"],"title":"JS逆向 - Python调用JS代码"},{"categories":[2020,"技术"],"contents":":::tip 一个具有实时重新加载功能的小型开发服务器 ::: 简介 这是一个具有实时重新加载功能的小型开发服务器。使用它来入侵您的HTML / JavaScript / CSS文件，而不是用于部署最终站点。 使用此文件有两个原因： file://由于安全限制，AJAX请求不适用于该协议，即，如果您的站点通过JavaScript获取内容，则您需要一台服务器。 文件更改后自动重新加载页面可以加快开发速度 安装 您需要node.js和npm。您可能应该在全局范围内安装它。 Npm方式 npm install -g live-server 手动方式 git clone https://github.com/tapio/live-server cd live-server npm install # Local dependencies if you want to hack npm install -g # Install globally 使用 live-server 在项目目录中发出命令。或者，可以添加路径以用作命令行参数。 这将自动启动默认浏览器。当您对任何文件进行更改时，浏览器都会重新加载页面-除非它是CSS文件，否则在不重新加载的情况下应用更改。 命令行参数： \u0026ndash;port=NUMBER -选择要使用的端口，默认：PORT env var或8080 \u0026ndash;host=ADDRESS -选择要绑定到的主机地址，默认情况下：IP env var或0.0.0.0（“任何地址”） \u0026ndash;no-browser -禁止自动启动Web浏览器 \u0026ndash;browser=BROWSER -指定要使用的浏览器，而不是系统默认值 \u0026ndash;quiet | -q -禁止记录 \u0026ndash;verbose | -V -更多日志记录（记录所有请求，显示所有侦听的IPv4接口，等等） \u0026ndash;open=PATH -将浏览器启动到PATH而不是服务器根目录 \u0026ndash;watch=PATH -以逗号分隔的路径字符串，专门用于监视更改（默认值：监视所有内容） \u0026ndash;ignore=PATH-逗号分隔的路径字符串，可以忽略（anymatch兼容定义） \u0026ndash;ignorePattern=RGXP-文件的正则表达式忽略（即.*.jade）（不推荐使用赞成\u0026ndash;ignore） \u0026ndash;no-css-inject -在CSS更改时重新加载页面，而不是注入更改的CSS \u0026ndash;middleware=PATH-导出要添加的中间件功能的.js文件的路径；可以是没有路径的名称，也不能是引用middleware文件夹中捆绑的中间件的扩展名 \u0026ndash;entry-file=PATH -提供此文件（相对于服务器根目录的文件）代替丢失的文件（对于单页应用程序很有用） \u0026ndash;mount=ROUTE:PATH -在定义的路线下投放路径内容（可能有多个定义） \u0026ndash;spa -将请求从/ abc转换为/＃/ abc（对于单页应用程序非常方便） \u0026ndash;wait=MILLISECONDS -（默认100ms）等待所有更改，然后重新加载 \u0026ndash;htpasswd=PATH -启用位于PATH的http-auth期望htpasswd文件 \u0026ndash;cors -为任何来源启用CORS（反映请求来源，支持带有凭据的请求） \u0026ndash;https=PATH -HTTPS配置模块的路径 \u0026ndash;https-module=MODULE_NAME-自定义HTTPS模块（例如spdy） \u0026ndash;proxy=ROUTE:URL -将所有对ROUTE的请求代理到URL \u0026ndash;help | -h -显示简洁的使用提示并退出 \u0026ndash;version | -v -显示版本并退出 ","permalink":"https://chenzqi.cn/posts/2020/20200504_live-server/","tags":["web","前端"],"title":"Live Server 实时服务器"},{"categories":[2020,"技术"],"contents":":::tip 联通内网工单登录系统破解流程 ::: 记录使用tkinter + python完成中国联通工单系统的抓取程序。使用VPN + fiddler + postman分析系统单点登录的流程。 单点登录（Single Sign On），简称为 SSO，是目前比较流行的企业业务整合的解决方案之一。SSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。 步骤 获取加密后的密码 获取appid，socp，tokenApi参数 获取token，soap，ltpa参数 完成认证，获取ut，pid 获取数据 流程 程序开始直接请求要抓取的数据URL，抓取失败说明未登录，走登录方法，然后重新抓取。 登录 def login(): username = \u0026#39;miaoxn3\u0026#39; password = pwd.get() # 如果未获取到密码，使用默认的加密密码 if not password: password = \u0026#39;090620mxnMXN!\u0026#39; # 第一步 获取加密密码 try: url0 = \u0026#34;http://sso.portal.unicom.local/eip_sso/rest/authentication/login\u0026#34; payload0 = \u0026#39;success=http%3A//service.aiportal.unicom.local/ssoclient/ssologin%3Faction%3Dlogin\u0026amp;error=http%\u0026#39; \\ \u0026#39;3A//sso.portal.unicom.local/eip_sso/aiportalLogin.html\u0026amp;return=http%3A//sso.portal.unicom.local/\u0026#39; \\ \u0026#39;eip_sso/aiportalLogin.html\u0026amp;appid=na186\u0026amp;login=miaoxn3\u0026amp;password={}\u0026#39;.format(password) headers0 = { \u0026#39;Host\u0026#39;: \u0026#39;sso.portal.unicom.local\u0026#39;, \u0026#39;Connection\u0026#39;: \u0026#39;keep-alive\u0026#39;, \u0026#39;Origin\u0026#39;: \u0026#39;http://sso.portal.unicom.local\u0026#39;, \u0026#39;Content-Type\u0026#39;: \u0026#39;application/x-www-form-urlencoded\u0026#39;, \u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.163 Safari/537.36\u0026#39;, \u0026#39;Content-Type\u0026#39;: \u0026#39;application/x-www-form-urlencoded\u0026#39; } response = session.post(url=url0, headers=headers0, data=payload0) password = re_search(r\u0026#39;id=\u0026#34;password\u0026#34; value=\u0026#34;(.*?)\u0026#34;/\u0026gt;\u0026#39;, response.text).group(1) except Exception as e: set_message(msg=\u0026#39;登陆失败\u0026#39;) return False print(password) # 第二步 获取appid，socp，tokenApi参数 try: url1 = \u0026#34;http://uac.sso.chinaunicom.cn:8282/uac-sso/login\u0026#34; payload1 = \u0026#39;fromAppID=20F9390D5D40ED95E552109364458DC1\u0026amp;success=http%3A//service.aiportal.unicom.local/ssoclient/ssologin\u0026#39; \\ \u0026#39;%3Faction%3Dlogin\u0026amp;error=http%3A//sso.portal.unicom.local/eip_sso/aiportalLogin.html\u0026amp;return=http%3A//\u0026#39; \\ \u0026#39;sso.portal.unicom.local/eip_sso/aiportalLogin.html\u0026amp;eipsuccess=http%3A//sso.portal.unicom.local%3A80/\u0026#39; \\ \u0026#39;eip_sso/rest/authentication/portalLogin\u0026amp;login={}\u0026amp;appid=na186\u0026amp;password={}\u0026#39;.format(username, password) headers1 = { \u0026#39;Host\u0026#39;: \u0026#39;uac.sso.chinaunicom.cn:8282\u0026#39;, \u0026#39;Origin\u0026#39;: \u0026#39;http://sso.portal.unicom.local\u0026#39;, \u0026#39;Content-Type\u0026#39;: \u0026#39;application/x-www-form-urlencoded\u0026#39;, \u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.163 Safari/537.36\u0026#39;, \u0026#39;Accept\u0026#39;: \u0026#39;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\u0026#39;, \u0026#39;Referer\u0026#39;: \u0026#39;http://sso.portal.unicom.local/eip_sso/rest/authentication/login\u0026#39;, \u0026#39;Cookie\u0026#39;: \u0026#39;UC_SSO_SESSIONID_WEB=0519B25947E84F4D83FF939CFE91457A\u0026#39;, \u0026#39;Content-Type\u0026#39;: \u0026#39;application/x-www-form-urlencoded\u0026#39; } response = session.post(url=url1, headers=headers1, data=payload1) soap = re_search(r\u0026#39;id=\u0026#34;soap\u0026#34; value=\\\u0026#39;(.*?)\\\u0026#39;\u0026gt;\u0026#39;, response.text).group(1) tokenApi = re_search(r\u0026#39;id=\u0026#34;tokenApi\u0026#34; value=\u0026#34;(.*?)\u0026#34;\u0026gt;\u0026#39;, response.text).group(1) except Exception as e: set_message(msg=\u0026#39;登陆失败\u0026#39;) return False # 第三步 获取token，soap，ltpa参数 try: url2 = \u0026#34;http://sso.portal.unicom.local/eip_sso/rest/authentication/portalLogin\u0026#34; payload2 = \u0026#39;appid=na186\u0026amp;error=http%3A//sso.portal.unicom.local/eip_sso/aiportalLogin.html\u0026amp;errorCode=0\u0026amp;\u0026#39; \\ \u0026#39;errorMessage=%u64CD%u4F5C%u6210%u529F\u0026amp;return=http%3A//sso.portal.unicom.local/eip_sso/aiportalLogin.html\u0026amp;\u0026#39; \\ \u0026#39;soap={soap}\u0026amp;tokenApi={tokenApi}\u0026amp;userId=\u0026#39;.format(soap=soap, tokenApi=tokenApi) headers2 = { \u0026#39;Host\u0026#39;: \u0026#39;sso.portal.unicom.local\u0026#39;, \u0026#39;Connection\u0026#39;: \u0026#39;keep-alive\u0026#39;, \u0026#39;Origin\u0026#39;: \u0026#39;http://uac.sso.chinaunicom.cn:8282\u0026#39;, \u0026#39;Content-Type\u0026#39;: \u0026#39;application/x-www-form-urlencoded\u0026#39;, \u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.163 Safari/537.36\u0026#39;, \u0026#39;Accept\u0026#39;: \u0026#39;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\u0026#39;, \u0026#39;Referer\u0026#39;: \u0026#39;http://uac.sso.chinaunicom.cn:8282/uac-sso/login\u0026#39;, \u0026#39;Cookie\u0026#39;: \u0026#39;JSESSIONID=CC8A69435BD9EF8060E5F43DBEB4B402; lastUid=miaoxn3; miaoxn3=hY2C5VeHiX%2FgFpM9bYQK%2Bg%3D%3D; LtpaToken=tQX78YHEEn1YBvIwIQdNNzNwQ8Sv9jiP4SReDet6rrVTfbwZ/SMsBKSL+VTC0boqM8qSZgnoRfi6veIJIWih+WySFrZAlaLmU58CgKe1WkT+kMos3jFFwr5jrCPPuDY4li2K8HVM9f1OB9mAQoselXjyw2AM3jGEeG+CdKLQh7dU7hmICoRl6OlNGJBxU1UKVwX1TqyevMX9pIwYb1ql+U7RFeVkoJYIH5ClZmezz3fYzNIckiuwlk8HxtjJyTfr3/5GJDfRRRNOgGrF/QjqQeX2LkfVm9x3FzJSSf5B3JSbyUgoOhr0EQ==; aiportalut=\u0026#39;, \u0026#39;Content-Type\u0026#39;: \u0026#39;application/x-www-form-urlencoded\u0026#39;, \u0026#39;Cookie\u0026#39;: \u0026#39;JSESSIONID=59703BB2816D0AE16249AD9ADE0C5F72\u0026#39; } response = session.post(url=url2, headers=headers2, data=payload2) # print(response.text) # token = re_search(r\u0026#39;name=\u0026#34;token\u0026#34; value=\\\u0026#39;(.*?)\\\u0026#39;\u0026gt;\u0026#39;, response.text, re_S).group(1) soap = re_search(r\u0026#39;name=\u0026#34;soap\u0026#34; value=\u0026#34;(.*?)\u0026#34;\u0026gt;\u0026#39;, response.text, re_S).group(1) ltpa = re_search(r\u0026#39;name=\u0026#34;ltpa\u0026#34; value=\\\u0026#39;(.*?)\\\u0026#39;;document\u0026#39;, response.text, re_S).group(1) # print(token) # print(soap) # print(ltpa) except Exception as e: set_message(msg=\u0026#39;登陆失败\u0026#39;) return False # 第四步 完成认证，获取ut，pid try: url3 = \u0026#34;http://service.aiportal.unicom.local/ssoclient/ssologin?action=login\u0026#34; # payload3 = \u0026#39;return=http%3A//sso.portal.unicom.local/eip_sso/aiportalLogin.html\u0026amp;soap={soap}\u0026amp;ltpa={ltpa}\u0026#39;.format(soap=soap, ltpa=ltpa) payload3 = { # \u0026#39;return\u0026#39;: \u0026#39;http://sso.portal.unicom.local/eip_sso/aiportalLogin.html\u0026#39;, \u0026#39;soap\u0026#39;: soap, \u0026#39;ltpa\u0026#39;: ltpa } headers3 = { \u0026#39;Host\u0026#39;: \u0026#39;service.aiportal.unicom.local\u0026#39;, \u0026#39;Origin\u0026#39;: \u0026#39;http://sso.portal.unicom.local\u0026#39;, \u0026#39;Content-Type\u0026#39;: \u0026#39;application/x-www-form-urlencoded\u0026#39;, \u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.163 Safari/537.36\u0026#39;, \u0026#39;Content-Type\u0026#39;: \u0026#39;application/x-www-form-urlencoded\u0026#39; } response = session.post(url=url3, headers=headers3, data=payload3) result = re_findall(r\u0026#39;pid=(.*?)\u0026amp;token=(.*?)\u0026amp;\u0026#39;, response.text, re_S) global pid global ut pid = result[0][0] ut = result[0][1] except Exception as e: # print(\u0026#39;3\u0026#39;, e) set_message(msg=\u0026#39;登陆失败\u0026#39;) return False else: set_message(msg=\u0026#39;登陆成功\u0026#39;) set_message(msg=\u0026#39;pid {}\u0026#39;.format(pid)) set_message(msg=\u0026#39;ut {}\u0026#39;.format(ut)) return True 抓取 ut, pid是登录成功获得的参数，抓取时带上 def get_current_data(): global page url = \u0026#34;http://service.aiportal.unicom.local/taskquery/taskpend/v1/list//0/{page}/10/all/?pendingTitle=\u0026amp;startTime=\u0026amp;endTime=\u0026amp;sort=DESC\u0026#34;.format( page=page) headers = { \u0026#39;Host\u0026#39;: \u0026#39;service.aiportal.unicom.local\u0026#39;, \u0026#39;Origin\u0026#39;: \u0026#39;http://aiportal.unicom.local\u0026#39;, \u0026#39;Referer\u0026#39;: \u0026#39;http://aiportal.unicom.local/modules/readyto/manageIndex.html?pendingState=daiban\u0026amp;type=all\u0026amp;version=20200304\u0026#39;, \u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.163 Safari/537.36\u0026#39;, \u0026#39;ut\u0026#39;: ut, \u0026#39;pid\u0026#39;: pid } try: response = session.get(url=url, headers=headers) data = json_loads(response.text) except: messagebox.showerror(title=\u0026#39;无权访问\u0026#39;, message=\u0026#39;无权限正常访问内网！\u0026#39;) else: ... 效果图 首页列表 详情页 数据导出 ","permalink":"https://chenzqi.cn/posts/2020/20200423_%E4%B8%AD%E5%9B%BD%E8%81%94%E9%80%9A%E5%B7%A5%E5%8D%95%E7%B3%BB%E7%BB%9F%E7%99%BB%E5%BD%95/","tags":["爬虫","工具"],"title":"中国联通工单系统登录"},{"categories":[2020,"技术"],"contents":":::tip PyQt5中使用多线程QThread模块 ::: 多线程模块QThread基本原理 QThread是Qt的线程类中最核心的底层类。由于PyQt的的跨平台特性，QThread要隐藏所有与平台相关的代码 要使用的QThread开始一个线程，可以创建它的一个子类，然后覆盖其它QThread.run()函数 class Thread(QThread): def __init__(self): super(Thread,self).__init__() def run(self): 接下来创建一个新的线程 thread = Thread() thread.start() 可以看出，PyQt的线程使用非常简单，建立一个自定义的类（如Thread），自我继承自QThread ，并实现其run()方法即可。在使用线程时可以直接得到Thread实例，调用其start()函数即可启动线程，线程启动之后，会自动调用其实现的run()的函数，该方法就是线程的执行函数 。 业务的线程任务就写在run()函数中，当run()退出之后线程就基本结束了，QThread有started和finished信号，可以为这两个信号指定槽函数，在线程启动和结束之时执行一段代码进行资源的初始化和释放操作，更灵活的使用方法是，在自定义的QThread实例中自定义信号，并将信号连接到指定的槽函数，当满足一定的业务条件时发射此信号。 QThread类中的常用方法 start()：启动线程 wait()：阻止线程，直到满足如下条件之一 与此QThread对象关联的线程已完成执行（即从run返回时），如果线程完成执行，此函数返回True，如果线程尚未启动，也返回True 等待时间的单位是毫秒，如果时间是ULONG_MAX（默认值·），则等待，永远不会超时(线程必须从run返回），如果等待超时，此函数将会返回False sleep()：强制当前线程睡眠多少秒 QThread类中的常用信号 started：在开始执行run函数之前，从相关线程发射此信号 finished：当程序完成业务逻辑时，从相关线程发射此信号 使用QThread重新实现程序解决问题 # -*- coding: utf-8 -*- import sys import time from PyQt5.QtCore import QThread, pyqtSignal from PyQt5.QtWidgets import QApplication, QMainWindow from QThread_Example_UI import Ui_Form class MyMainForm(QMainWindow, Ui_Form): def __init__(self, parent=None): super(MyMainForm, self).__init__(parent) self.setupUi(self) # 实例化线程对象 self.work = WorkThread() self.runButton.clicked.connect(self.execute) def execute(self): # 启动线程 self.work.start() # 线程自定义信号连接的槽函数 self.work.trigger.connect(self.display) def display(self,str): # 由于自定义信号时自动传递一个字符串参数，所以在这个槽函数中要接受一个参数 self.listWidget.addItem(str) class WorkThread(QThread): # 自定义信号对象。参数str就代表这个信号可以传一个字符串 trigger = pyqtSignal(str) def __int__(self): # 初始化函数 super(WorkThread, self).__init__() def run(self): #重写线程执行的run函数 #触发自定义信号 for i in range(20): time.sleep(1) # 通过自定义信号把待显示的字符串传递给槽函数 self.trigger.emit(str(i)) if __name__ == \u0026#34;__main__\u0026#34;: app = QApplication(sys.argv) myWin = MyMainForm() myWin.show() sys.exit(app.exec_()) 小结 如果实现的工具需要执行特别耗时的操作，可以使用本文多线程QThread处理方法实现。当然，工具实际实现过程中的场景会比这复杂。比如，你的输出并不是有固定时间间隔输出的文本框，可以尝试使用多次self.trigger.emit(str)方法进行操作。 ","permalink":"https://chenzqi.cn/posts/2020/20200420_pyqt5%E4%B8%AD%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9D%97qthread%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","tags":["工具"],"title":"PyQt5多线程模块QThread使用"},{"categories":[2020,"技术"],"contents":":::tip TB网页登录流程解析，使用Python代码实现登录后保存Cookie信息 ::: 一、淘宝登录流程 淘宝ua参数：ua(User-Agent)故名用户代理，淘宝的ua参数加入了浏览器、ip、电脑、时间等信息，然后加密生成，在很多地方使用，不仅仅是登录 从代码层面考虑将模拟登录淘宝分为以下四个步骤： 输入用户名后，浏览器会向淘宝（taobao.com）发起一个post的请求，判断是否出现滑块验证！ 用户输入密码后，浏览器向淘宝（taobao.com）又发起一个post请求，验证用户名密码是否正确，如果正确则返回一个token。 浏览器拿着token去阿里巴巴（alibaba.com）交换st码！ 浏览器获取st码之后，拿着st码获取cookies，登录成功 二、模拟登录实现 1.判断是否需要滑块 举个例子：某台设备可能出现登录过大量的账号，这时候淘宝就可以从ua参数中获取设备号，然后对该设备进行限制！ 2.验证用户名密码 这里一步也就是上面时序图图中的第5步：请求登录，这里会将用户名、ua参数、加密密码等参数post到淘宝（taobao.com）去验证。 验证账号密码获取st码申请地址 结果 可以看到申请st码链接后面带了一个token 3.申请st码 申请到了淘宝（taobao.com）的token，这一步就是用token来换取st码 为什么淘宝登录需要这么麻烦呢？直接在 taobao.com 登录不就可以吗？为什么要先在taobao验证用户名密码，通过之后再去 alibaba.com 换取st码登录呢？ 任何公司的框架都是慢慢演变的结果，我想最开始的淘宝登录肯定没这么复杂。但是随着阿里巴巴的慢慢壮大，很多事业线都划分开来，但是这些事业线之间又有关联性，比如用户登录了淘宝账号之后天猫就不需要再登录了呢？（注意淘宝和天猫的顶级域名不同，所以不能共享cookis）为了解决这个问题，单点登录就出现了。 单点登录（Single Sign On），简称为 SSO，是目前比较流行的企业业务整合的解决方案之一。SSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。 ——百度百科 用户数据在淘宝这里，所以需要现在淘宝（taobao.com）验证用户名和密码，验证通过生成一个token，浏览器拿着token去和阿里巴巴（alibaba.com）申请单点登录码（st码），阿里巴巴收到请求验证token通过则返回st码，所以用token换st码的原因就在于单点登录！ 4.使用st码登录 成功获取st码之后我们就可以来登录了，这一步是通过st码获取登录的cookies并保存 三 、验证cookie 每次运行加载本地cookies文件，判断是否过期。 ","permalink":"https://chenzqi.cn/posts/2020/20200415_python-%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95%E6%B7%98%E5%AE%9D%E4%B8%8Ecookies%E5%BA%8F%E5%88%97%E5%8C%96/","tags":["爬虫"],"title":"模拟登录TB与Cookies序列化"},{"categories":[2020,"技术"],"contents":"scrapy-splash的介绍 Scrapy没有JS engine, 无法爬取JavaScript生成的动态网页，只能爬取静态网页，而在现代的网络世界中，大部分网页都会采用JavaScript来丰富网页的功能。 scrapy-splash模块主要使用了Splash. 所谓的Splash, 就是一个Javascript渲染服务。它是一个实现了HTTP API的轻量级浏览器，Splash是用Python实现的，同时使用Twisted和QT。Twisted（QT）用来让服务具有异步处理能力，以发挥webkit的并发能力。Splash的特点如下： 并行处理多个网页 得到HTML结果以及（或者）渲染成图片 关掉加载图片或使用 Adblock Plus规则使得渲染速度更快 使用JavaScript处理网页内容 使用Lua脚本 能在Splash-Jupyter Notebooks中开发Splash Lua scripts 能够获得具体的HAR格式的渲染信息 scrapy-splash的安装 安装scrapy-splash模块 pip3 install scrapy-splash scrapy-splash使用的是Splash HTTP API， 所以需要一个splash instance，一般采用docker运行splash，所以需要安装docker。 CentOS7 sudo yum install docker 开启docker服务，拉取splash镜像（pull the image） sudo service docker start sudo docker pull scrapinghub/splash 开启容器（start the container） sudo docker run -p 8050:8050 scrapinghub/splash 此时Splash以运行在本地服务器的端口8050(http)，在浏览器中输入\u0026rsquo;IP:8050' scrapy-splash的实例 一个简单的实例，利用百度查询手机号码信息。比如，在百度输入框中输入手机号码‘159’，然后查询，得到如下信息 利用scrapy-splash模拟以上操作并获取手机号码信息 创建scrapy项目phone 配置settings.py文件，配置的内容如下 ROBOTSTXT_OBEY = False SPIDER_MIDDLEWARES = { \u0026#39;scrapy_splash.SplashDeduplicateArgsMiddleware\u0026#39;: 100, } DOWNLOADER_MIDDLEWARES = { \u0026#39;scrapy_splash.SplashCookiesMiddleware\u0026#39;: 723, \u0026#39;scrapy_splash.SplashMiddleware\u0026#39;: 725, \u0026#39;scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware\u0026#39;: 810 } SPLASH_URL = \u0026#39;http://localhost:8050\u0026#39; DUPEFILTER_CLASS = \u0026#39;scrapy_splash.SplashAwareDupeFilter\u0026#39; HTTPCACHE_STORAGE = \u0026#39;scrapy_splash.SplashAwareFSCacheStorage\u0026#39; 具体的配置说明可以参考: scrapy-splash 创建爬虫文件phoneSpider.py, 代码如下 # -*- coding: utf-8 -*- from scrapy import Spider, Request from scrapy_splash import SplashRequest # splash lua script script = \u0026#34;\u0026#34;\u0026#34; function main(splash, args) assert(splash:go(args.url)) assert(splash:wait(args.wait)) js = string.format(\u0026#34;document.querySelector(\u0026#39;#kw\u0026#39;).value=%s;document.querySelector(\u0026#39;#su\u0026#39;).click()\u0026#34;, args.phone) splash:evaljs(js) assert(splash:wait(args.wait)) return splash:html() end \u0026#34;\u0026#34;\u0026#34; class phoneSpider(Spider): name = \u0026#39;phone\u0026#39; allowed_domains = [\u0026#39;www.baidu.com\u0026#39;] url = \u0026#39;https://www.baidu.com\u0026#39; # start request def start_requests(self): yield SplashRequest(self.url, callback=self.parse, endpoint=\u0026#39;execute\u0026#39;, args={\u0026#39;lua_source\u0026#39;: script, \u0026#39;phone\u0026#39;:\u0026#39;159*******\u0026#39;, \u0026#39;wait\u0026#39;: 5}) # parse the html content def parse(self, response): info = response.css(\u0026#39;div.op_mobilephone_r.c-gap-bottom-small\u0026#39;).xpath(\u0026#39;span/text()\u0026#39;).extract() print(\u0026#39;=\u0026#39;*40) print(\u0026#39;\u0026#39;.join(info)) print(\u0026#39;=\u0026#39;*40) 运行爬虫: scrapy crawl phone ","permalink":"https://chenzqi.cn/posts/2020/20200409_scrapy-splash%E7%9A%84%E4%BD%BF%E7%94%A8/","tags":["爬虫","框架","scrapy"],"title":"Scrapy-Splash的使用"},{"categories":[2020,"技术"],"contents":"Tornado简介 Tornado-基于Python的web服务端框架， 与现有主流的web服务端（以及大多数Python框架）有着明显的区别： 是非阻塞式，速度相当快。得利于其非阻塞式的方式，Tornado每秒可以处理数以千计的连接，因此是实时web服务的一个理想框架。 Tornado安装 pip install tornado Tornado web程序流程 创建web应用实例对象，第一个初始化参数为路由映射列表 定义实现路由映射列表的handler类 创建实例，监听服务器端口 启动。执行IOLoop类的start()方法 处理HTTP请求 RequestHandler.get(args,kwargs) #处理get请求 RequestHandler.post(*args, kwargs) #处理post请求 RequestHandler.put(args, kwargs) #处理put请求 RequestHandler.delete(*args, kwargs) #处理delete请求 Hello world import tornado.ioloop import tornado.web # 定义实现路由映射列表的handler类 class MainHandler(tornado.web.RequestHandler): def get(self): self.write(\u0026#34;Hello world\u0026#34;) class Application(tornado.web.Application): def __init__(self): handlers = [ (r\u0026#39;/\u0026#39;, MainHandler), ] # 创建web应用实例对象，第一个初始化参数为路由映射列表 tornado.web.Application.__init__(self, handlers) if __name__==\u0026#34;__main__\u0026#34;: app = Application() # 创建实例，监听服务器端口 app.listen(8000) print(\u0026#34;Tornado Started in port 8000，http://127.0.0.1:8000\u0026#34;) # 启动。执行IOLoop类的start()方法 tornado.ioloop.IOLoop.current().start() Hello world创建了一个socket服务并监听8000端口，当接收到请求时根据路由规则来找到相应的类处理该请求，并根据请求方式指定相应类中的指定方法处理。 所以当我们在浏览器键入127.0.0.1:8000，服务端会给浏览器返回Hello world。 ","permalink":"https://chenzqi.cn/posts/2020/20200405_%E5%9F%BA%E4%BA%8Epython%E7%9A%84tornado%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/","tags":["框架"],"title":"基于Python的Tornado框架入门记录"},{"categories":[2020,"技术"],"contents":"Homebrew是一款Mac OS平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能 问题： macOS安装Homebrew时总是报错（Failed to connect to raw.githubusercontent.com port 443: Connection refused） 原因： GitHub的raw.githubusercontent.com域名解析被污染了。 解决： 通过修改hosts解决此问题。 解决 在 www.ipaddress.com 查询 raw.githubusercontent.com 的真实IP。 修改hosts: sudo vim /etc/hosts 添加如下内容: 199.232.28.133 raw.githubusercontent.com hosts 权限 方法1 打开Finder，按快捷键组合 Shift+Command+G 查找文件，输入/etc/hosts,确认前往 进入文件夹后，复制该文件到桌面，修改成功后保存，将原先的host文件替换掉即可 方法2 打开Finder，按快捷键组合 Shift+Command+G 查找文件，输入/private,确认前往后可看到 etc 文件夹，邮件选择\u0026rsquo;显示简介\u0026rsquo;，在底部打开‘共享和权限’ 将everyone的权限改为‘读与写’，保存后直接修改hosts文件，最后完成后将权限改回来 ","permalink":"https://chenzqi.cn/posts/2020/20200401_macos%E5%AE%89%E8%A3%85homebrew%E9%97%AE%E9%A2%98/","tags":["问题","记录"],"title":"macOS安装Homebrew问题"},{"categories":[2020,"技术"],"contents":":::tip 使用Dockerfile部署项目,docker安装不同软件 ::: 部署java项目 创建Dockerfile # 基础镜像是docker仓库的java:8（也就是jdk8的意思） FROM java:8 # 作者签名 MAINTAINER xiaoxiang # 简化 jar 的名字路径 （左边是服务器中jar包的路径，因为当前文件是和jar包同级，所以直接写名字即可，右边是镜像中要存放jar包的路径） COPY test.jar /test.jar # 设置时间 RUN ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \u0026amp;\u0026amp; echo \u0026#39;Asia/Shanghai\u0026#39; \u0026gt;/etc/timezone # 执行 java -jar 命令 （CMD：在启动容器时才执行此行。RUN：构建镜像时就此行，后面的jar包路径就是上面要设置的jar包路径） CMD java -jar /test.jar # 设置对外端口为 8080 EXPOSE 8080 创建镜像 # 后面有个点，指定路径为当前路径的Dockerfile文件 docker build -t test . 运行jar包 -d代表后台运行 -p 8082:8082 端口映射，后一个8082是镜像的端口 -v 代表挂载一个宿主机目录到容器目录中，第一个是宿主机目录，第二个是容器目录 第一个test/java代表是给容器的名字 第二个test是上面创建镜像的名字 docker run -d -p 8080:8080 -v /opt/java:/opt/java --name test/java test 查看容器 docker ps -a 软件安装 安装Mysql mkdir -p /opt/data/mysql/data mkdir -p /opt/data/mysql/conf.d docker run -di -p 3307:3306 -v /opt/data/mysql/conf.d:/etc/mysql/conf.d -v /opt/data/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=密码 --name mysql mysql 安装Redis mkdir -p /opt/data/redis/data mkdir -p /opt/data/redis/conf vim /opt/data/redis/conf/redis.conf docker run -d -p 6379:6379 --name redis -v /opt/data/redis/redis.conf:/etc/redis/redis.conf -v /opt/data/redis/data:/data redis redis-server /etc/redis/redis.conf --requirepass \u0026#34;密码\u0026#34; --appendonly yes redis.conf protected-mode yes port 6379 tcp-backlog 511 timeout 0 daemonize yes supervised no pidfile /var/run/redis_6379.pid loglevel notice logfile /var/log/redis/redis.log databases 16 save 900 1 save 300 10 save 60 10000 stop-writes-on-bgsave-error yes rdbcompression yes rdbchecksum yes dbfilename dump.rdb dir /var/lib/redis slave-serve-stale-data yes slave-read-only yes repl-diskless-sync no repl-diskless-sync-delay 5 repl-disable-tcp-nodelay no slave-priority 100 requirepass 密码 appendonly no appendfilename \u0026#34;appendonly.aof\u0026#34; appendfsync everysec no-appendfsync-on-rewrite no auto-aof-rewrite-percentage 100 auto-aof-rewrite-min-size 64mb aof-load-truncated yes lua-time-limit 5000 slowlog-log-slower-than 10000 slowlog-max-len 128 latency-monitor-threshold 0 notify-keyspace-events \u0026#34;\u0026#34; hash-max-ziplist-entries 512 hash-max-ziplist-value 64 list-max-ziplist-size -2 list-compress-depth 0 set-max-intset-entries 512 zset-max-ziplist-entries 128 zset-max-ziplist-value 64 hll-sparse-max-bytes 3000 activerehashing yes client-output-buffer-limit normal 0 0 0 client-output-buffer-limit slave 256mb 64mb 60 client-output-buffer-limit pubsub 32mb 8mb 60 hz 10 aof-rewrite-incremental-fsync yes 安装nginx mkdir -p /opt/data/nginx/{conf,html,logs} vim /usr/nginx/conf/nginx.conf docker run --name nginx -d -p 80:80 -p 443:443 -v /opt/data/nginx/html:/usr/share/nginx/html:ro -v /opt/data/nginx/conf/nginx.conf:/etc/nginx/nginx.conf:ro -v /opt/data/nginx/conf.d:/etc/nginx/conf.d:ro -v /opt/data/nginx/logs:/var/log/nginx nginx nginx.conf user nginx; worker_processes auto; error_log /var/log/nginx/error.log; pid /run/nginx.pid; include /usr/share/nginx/modules/*.conf; events { worker_connections 1024; } http { log_format main \u0026#39;$remote_addr - $remote_user [$time_local] \u0026#34;$request\u0026#34; \u0026#39; \u0026#39;$status $body_bytes_sent \u0026#34;$http_referer\u0026#34; \u0026#39; \u0026#39;\u0026#34;$http_user_agent\u0026#34; \u0026#34;$http_x_forwarded_for\u0026#34;\u0026#39;; access_log /var/log/nginx/access.log main; sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; include /etc/nginx/mime.types; default_type application/octet-stream; server { listen 80 default_server; listen [::]:80 default_server; server_name _; root /usr/share/nginx/html; include /etc/nginx/default.d/*.conf; location / { } error_page 404 /404.html; location = /40x.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { } } # Settings for a TLS enabled server. # # server { # listen 443 ssl http2 default_server; # listen [::]:443 ssl http2 default_server; # server_name _; # root /usr/share/nginx/html; # # ssl_certificate \u0026#34;/etc/pki/nginx/server.crt\u0026#34;; # ssl_certificate_key \u0026#34;/etc/pki/nginx/private/server.key\u0026#34;; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 10m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # # # Load configuration files for the default server block. # include /etc/nginx/default.d/*.conf; # # location / { # } # # error_page 404 /404.html; # location = /40x.html { # } # # error_page 500 502 503 504 /50x.html; # location = /50x.html { # } # } } 安装nacos 使用挂载文件的方式 mkdir -p /opt/nacos/logs mkdir -p /opt/nacos/conf touch /opt/nacos/conf/application.properties docker run -d --name nacos \\ -v /opt/nacos/conf/application.properties:/home/nacos/conf/application.properties \\ -v /opt/nacos/conf/logs:/home/nacos/conf/logs \\ -p 8848:8848 nacos/nacos-server application.properties server.servlet.contextPath=/nacos server.port=8848 nacos.naming.empty-service.auto-clean=false nacos.naming.empty-service.clean.initial-delay-ms=60000 nacos.naming.empty-service.clean.period-time-ms=20000 management.metrics.export.elastic.enabled=false management.metrics.export.influx.enabled=false server.tomcat.accesslog.enabled=true server.tomcat.accesslog.pattern=%h %l %u %t \u0026#34;%r\u0026#34; %s %b %D %{User-Agent}i server.tomcat.basedir= nacos.security.ignore.urls=/,/error,/**/*.css,/**/*.js,/**/*.html,/**/*.map,/**/*.svg,/**/*.png,/**/*.ico,/console-fe/public/**,/v1/auth/**,/v1/console/health/**,/actuator/**,/v1/console/server/** nacos.core.auth.system.type=nacos nacos.core.auth.enabled=false nacos.core.auth.default.token.expire.seconds=18000 nacos.core.auth.default.token.secret.key=SecretKey012345678901234567890123456789012345678901234567890123456789 nacos.core.auth.caching.enabled=false nacos.istio.mcp.server.enabled=false spring.datasource.platform=mysql db.num=1 db.url.0=jdbc:mysql://127.0.0.1:3306/nacos_config?characterEncoding=utf8\u0026amp;connectTimeout=1000\u0026amp;socketTimeout=3000\u0026amp;autoReconnect=true db.user=root db.password=123456 安装elasticSearch 安装 docker run -d --name es -p 9200:9200 -p 9300:9300 -e \u0026#34;discovery.type=single-node\u0026#34; docker.elastic.co/elasticsearch/elasticsearch:7.6.2 配置跨域和密码 # 进入容器 docker exec -it es /bin/bash # 编辑文件 vi config/elasticsearch.yml # 名称，保证唯一 cluster.name: es-1 # 为本机ip地址,docker中为0.0.0.0 network.host: 0.0.0.0 # 打开跨域，选填 http.cors.enabled: true http.cors.allow-origin: \u0026#34;*\u0026#34; http.cors.allow-headers: Authorization # 开启安全认证，选填 xpack.security.enabled: true xpack.security.transport.ssl.enabled: true # 重启镜像 docker restart es # 设置密码，进入bin目录 # 需要为4个用户分别设置密码：elastic、kibana、logstash_system、beats_system cd /usr/local/kibana-7.6.2-linux-x86_64/bin \u0026amp;\u0026amp; ./elasticsearch-setup-passwords interactive # 浏览器查看 192.168.0.18:9200 安装中文分词 GitHub下载 # 下载后解压移动到/usr/share/elasticsearch/plugins，重启 docker cp elasticsearch-analysis-ik-7.8.0/ es:/usr/share/elasticsearch/plugins docker restart es 安装Kibana 创建配置文件 server.name: kibana server.host: \u0026#34;0\u0026#34; # elasticSearch地址 elasticsearch.hosts: [ \u0026#34;http://127.0.0.1:9200\u0026#34; ] xpack.monitoring.ui.container.elasticsearch.enabled: true #添加密码数据 elasticsearch.username: \u0026#34;elastic\u0026#34; elasticsearch.password: \u0026#34;xxx\u0026#34; 安装 docker run -d --log-driver json-file --log-opt max-size=100m --log-opt max-file=2 --name kibana -p 5601:5601 -v /opt/kibana/kibana.yml:/usr/share/kibana/config/kibana.yml kibana:7.4.1 # 浏览器查看 127.0.0.1:5601 安装Oracle11g 下载Oracle 11g R2安装包 # 创建目录 mkdir -p /opt/oracle/install/database # 解压下载的文件 unzip -d linux.x64_11gR2_database_1of2.zip /opt/oracle/install/database unzip -d linux.x64_11gR2_database_2of2.zip /opt/oracle/install/database # 安装,安装过程很久，可能会卡在终端,可以新开一个终端查看是否安装完成 docker run --privileged --name oracle -p 1521:1521 -v /opt/oracle/install/database:/install docker.io/jaspeen/oracle-11g # 进入容器 docker exec -it oracle11g /bin/bash # 切换到oracle用户 su - oracle # 进入数据库 sqlplus / as sysdba -- 创建一个用户 create user username identified by password; -- 给用户授权 grant create session,create table,create sequence,unlimited tablespace to username; 出现数据库不能连接错误 拷贝容器中的timezone文件到本地 # 第一个名字是容器和路径，第二个点代表拷贝到当前目录下 docker cp test/java:/etc/timezone . 修改 Etc/CST 放回原位 # 在文件所在的目录下拷贝到容器的 /etc/下 docker cp timezone 容器名称:/etc/ Docker访问宿主机 vim /etc/firewalld/zones/public.xml 添加 \u0026lt;rule family=\u0026#34;ipv4\u0026#34;\u0026gt; \u0026lt;source address=\u0026#34;172.17.0.0/16\u0026#34; /\u0026gt; \u0026lt;accept /\u0026gt; \u0026lt;/rule\u0026gt; 重启防火墙 systemctl restart firewalld Docker命令自动补全 yum install -y bash-completion source /usr/share/bash-completion/bash_completion source /usr/share/bash-completion/completions/docker 设置自启 设置自启动 docker update --restart=always 容器id 关闭自启动 docker update --restart=no 容器id 关闭所有自启动 docker update --restart=no $(docker ps -q) ","permalink":"https://chenzqi.cn/posts/2020/20200325_docker%E9%A1%B9%E7%9B%AE%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95%E9%9B%86/","tags":["Docker"],"title":"Docker项目安装记录集"},{"categories":[2019,"技术"],"contents":":::tip 解决某考研查询某小程序jwt权限认证与采集 ::: 前言 日常采集数据时, 有很多需要登录才能获取的数据, 不能解决权限认证这个问题, 就无法获取到想要采集的数据, 目下流行的认证机制有session, token 与 JWT, 最近写爬虫遇到这个问题, 记录下解决方法 爬虫需求 如图: 获取每个高校详情页的上 中 下 三部分类容 列表页 详情页 项目逻辑 使用Fiddler抓包, 查看响应数据结构 对应字段创建数据库表 编写爬虫代码 解决权限认证问题 解析数据, 保存数据 抓包 认证 第一次进小程序是, 一般都会弹出微信授权, 这个也就是服务后端用来登录的接口, 抓包发现返回登录成功的数据, token结构是无疑问后端采集的是 JWT 认证机制, 有了登录接口, 采集就好办了, 而JWT的使用在请求时Headers中带上Authorization参数 列表页 详情页 ::: tip 总结 在请求接口时, 全程携带认证令牌且保证令牌有效, 否则无法获取数据 ::: 建表 爬虫 使用scrapy框架开发 起始函数 详情页函数 写入数据库 下载中间件 这步就是实现携带令牌访问的代码, 需要在配置开启此中间件 加了随机请求头功能, 代理ip也可在此中间件加入 配置文件 配置数据库信息 结果 输出 数据 20分钟采集了1万条数据 ","permalink":"https://chenzqi.cn/posts/2019/20190620_xxx%E8%80%83%E7%A0%94%E6%9F%A5%E8%AF%A2%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%88%AC%E8%99%AB/","tags":["框架","scrapy","爬虫"],"title":"某考研查询微信小程序爬虫"},{"categories":[2019,"技术"],"contents":"简介 分布式的实时文档存储，每个字段可以被索引与搜索 分布式实时分析搜索引擎 胜任上百个服务节点的扩展，支持 PB 级别的结构化或者非结构化数据 Elasticsearch 的安装 Elasticsearch官方网站。 下载安装包并解压，然后运行 bin/elasticsearch（Mac 或 Linux） 或者 bin\\elasticsearch.bat (Windows) 即可启动 Elasticsearch。 Mac 下推荐使用 Homebrew 安装： 安装Homebrew问题 brew install elasticsearch Elasticsearch 默认会在 9200 端口上运行，我们打开浏览器访问 http://localhost:9200/ 就可以看到类似内容 { \u0026#34;name\u0026#34; : \u0026#34;atntrTf\u0026#34;, \u0026#34;cluster_name\u0026#34; : \u0026#34;elasticsearch\u0026#34;, \u0026#34;cluster_uuid\u0026#34; : \u0026#34;e64hkjGtTp6_G2h1Xxdv5g\u0026#34;, \u0026#34;version\u0026#34; : { \u0026#34;number\u0026#34;: \u0026#34;6.2.4\u0026#34;, \u0026#34;build_hash\u0026#34;: \u0026#34;ccec39f\u0026#34;, \u0026#34;build_date\u0026#34;: \u0026#34;2018-04-12T20:37:28.497551Z\u0026#34;, \u0026#34;build_snapshot\u0026#34;: false, \u0026#34;lucene_version\u0026#34;: \u0026#34;7.2.1\u0026#34;, \u0026#34;minimum_wire_compatibility_version\u0026#34;: \u0026#34;5.6.0\u0026#34;, \u0026#34;minimum_index_compatibility_version\u0026#34;: \u0026#34;5.0.0\u0026#34; }, \u0026#34;tagline\u0026#34; : \u0026#34;You Know, for Search\u0026#34; } 版本很重要，以后安装一些插件都要做到版本对应才可以。 Elasticsearch 相关概念 在 Elasticsearch 中有几个基本的概念，如节点、索引、文档等。 Node 和 Cluster Elasticsearch 本质上是一个分布式数据库，允许多台服务器协同工作，每台服务器可以运行多个 Elasticsearch 实例。 单个 Elasticsearch 实例称为一个节点（Node）。一组节点构成一个集群（Cluster）。 Index Elasticsearch 会索引所有字段，经过处理后写入一个反向索引（Inverted Index）。查找数据的时候，直接查找该索引。 所以，Elasticsearch 数据管理的顶层单位就叫做 Index（索引），其实就相当于 MySQL、MongoDB 等里面的数据库的概念。另外值得注意的是，每个 Index （即数据库）的名字必须是小写。 Document Index 里面单条的记录称为 Document（文档）。许多条 Document 构成了一个 Index。 Document 使用 JSON 格式表示，下面是一个例子。 同一个 Index 里面的 Document，不要求有相同的结构（scheme），但是最好保持相同，这样有利于提高搜索效率。 Type Document 可以分组，比如 weather 这个 Index 里面，可以按城市分组（北京和上海），也可以按气候分组（晴天和雨天）。这种分组就叫做 Type，它是虚拟的逻辑分组，用来过滤 Document，类似 MySQL 中的数据表，MongoDB 中的 Collection。 不同的 Type 应该有相似的结构（Schema），举例来说，id 字段不能在这个组是字符串，在另一个组是数值。这是与关系型数据库的表的一个区别。性质完全不同的数据（比如 products 和 logs）应该存成两个 Index，而不是一个 Index 里面的两个 Type（虽然可以做到）。 根据规划，Elastic 6.x 版只允许每个 Index 包含一个 Type，7.x 版将会彻底移除 Type。 Fields 即字段，每个 Document 都类似一个 JSON 结构，它包含了许多字段，每个字段都有其对应的值，多个字段组成了一个 Document，其实就可以类比 MySQL 数据表中的字段。 在 Elasticsearch 中，文档归属于一种类型（Type），而这些类型存在于索引（Index）中，些简单的对比图来类比传统关系型数据库： Relational DB -\u0026gt; Databases -\u0026gt; Tables -\u0026gt; Rows -\u0026gt; Columns Elasticsearch -\u0026gt; Indices -\u0026gt; Types -\u0026gt; Documents -\u0026gt; Fields Python 对接 Elasticsearch Elasticsearch 提供了一系列 Restful API 来进行存取和查询操作，可以使用 curl 等命令来进行操作。这里直接利用 Python 来对接 Elasticsearch 的相关方法。 Python 中对接 Elasticsearch 使用的就是一个同名的库： pip3 install elasticsearch 官方文档，后面的内容也是基于官方文档。 创建 Index 创建一个名为 news 的索引： from elasticsearch import Elasticsearch es = Elasticsearch() result = es.indices.create(index=\u0026#39;news\u0026#39;, ignore=400) print(result) 创建成功，会返回如下结果： {\u0026#39;acknowledged\u0026#39;: True, \u0026#39;shards_acknowledged\u0026#39;: True, \u0026#39;index\u0026#39;: \u0026#39;news\u0026#39;} 返回结果是 JSON 格式，其中的 acknowledged 字段表示创建操作执行成功。 如果把代码执行一次的话，就会返回如下结果： {\u0026#39;error\u0026#39;: {\u0026#39;root_cause\u0026#39;: [{\u0026#39;type\u0026#39;: \u0026#39;resource_already_exists_exception\u0026#39;, \u0026#39;reason\u0026#39;: \u0026#39;index [news/QM6yz2W8QE-bflKhc5oThw] already exists\u0026#39;, \u0026#39;index_uuid\u0026#39;: \u0026#39;QM6yz2W8QE-bflKhc5oThw\u0026#39;, \u0026#39;index\u0026#39;: \u0026#39;news\u0026#39;}], \u0026#39;type\u0026#39;: \u0026#39;resource_already_exists_exception\u0026#39;, \u0026#39;reason\u0026#39;: \u0026#39;index [news/QM6yz2W8QE-bflKhc5oThw] already exists\u0026#39;, \u0026#39;index_uuid\u0026#39;: \u0026#39;QM6yz2W8QE-bflKhc5oThw\u0026#39;, \u0026#39;index\u0026#39;: \u0026#39;news\u0026#39;}, \u0026#39;status\u0026#39;: 400} 它提示创建失败，status 状态码是 400，错误原因是 Index 已经存在了。 注意这里代码里面使用了 ignore 参数为 400，这说明如果返回结果是 400 的话，就忽略这个错误不会报错，程序不会执行抛出异常。 假如不加 ignore 这个参数的话： es = Elasticsearch() result = es.indices.create(index=\u0026#39;news\u0026#39;) print(result) 再次执行就会报错了： raise HTTP_EXCEPTIONS.get(status_code, TransportError)(status_code, error_message, additional_info) elasticsearch.exceptions.RequestError: TransportError(400, \u0026#39;resource_already_exists_exception\u0026#39;, \u0026#39;index [news/QM6yz2W8QE-bflKhc5oThw] already exists\u0026#39;) 这样程序的执行就会出现问题，所以需要善用 ignore 参数，把一些意外情况排除，这样可以保证程序的正常执行而不会中断。 删除 Index 删除 Index 也是类似的，代码如下： from elasticsearch import Elasticsearch es = Elasticsearch() result = es.indices.delete(index=\u0026#39;news\u0026#39;, ignore=[400, 404]) print(result) 这里也是使用了 ignore 参数，来忽略 Index 不存在而删除失败导致程序中断的问题。 如果删除成功，会输出如下结果： {\u0026#39;acknowledged\u0026#39;: True} 如果 Index 已经被删除，再执行删除则会输出如下结果： {\u0026#39;error\u0026#39;: {\u0026#39;root_cause\u0026#39;: [{\u0026#39;type\u0026#39;: \u0026#39;index_not_found_exception\u0026#39;, \u0026#39;reason\u0026#39;: \u0026#39;no such index\u0026#39;, \u0026#39;resource.type\u0026#39;: \u0026#39;index_or_alias\u0026#39;, \u0026#39;resource.id\u0026#39;: \u0026#39;news\u0026#39;, \u0026#39;index_uuid\u0026#39;: \u0026#39;_na_\u0026#39;, \u0026#39;index\u0026#39;: \u0026#39;news\u0026#39;}], \u0026#39;type\u0026#39;: \u0026#39;index_not_found_exception\u0026#39;, \u0026#39;reason\u0026#39;: \u0026#39;no such index\u0026#39;, \u0026#39;resource.type\u0026#39;: \u0026#39;index_or_alias\u0026#39;, \u0026#39;resource.id\u0026#39;: \u0026#39;news\u0026#39;, \u0026#39;index_uuid\u0026#39;: \u0026#39;_na_\u0026#39;, \u0026#39;index\u0026#39;: \u0026#39;news\u0026#39;}, \u0026#39;status\u0026#39;: 404} 这个结果表明当前 Index 不存在，删除失败，返回的结果同样是 JSON，状态码是 400，但是由于我们添加了 ignore 参数，忽略了 400 状态码，因此程序正常执行输出 JSON 结果，而不是抛出异常。 插入数据 Elasticsearch 就像 MongoDB 一样，在插入数据的时候可以直接插入结构化字典数据，插入数据可以调用 create() 方法，插入一条新闻数据： from elasticsearch import Elasticsearch es = Elasticsearch() es.indices.create(index=\u0026#39;news\u0026#39;, ignore=400) data = {\u0026#39;title\u0026#39;: \u0026#39;美国留给伊拉克的是个烂摊子吗\u0026#39;, \u0026#39;url\u0026#39;: \u0026#39;http://view.news.qq.com/zt2011/usa_iraq/index.htm\u0026#39;} result = es.create(index=\u0026#39;news\u0026#39;, doc_type=\u0026#39;politics\u0026#39;, id=1, body=data) print(result) 这里首先声明了一条新闻数据，包括标题和链接，然后通过调用 create() 方法插入了这条数据，在调用 create() 方法时，我们传入了四个参数，index 参数代表了索引名称，doc_type 代表了文档类型，body 则代表了文档具体内容，id 则是数据的唯一标识 ID。 运行结果如下： {\u0026#39;_index\u0026#39;: \u0026#39;news\u0026#39;, \u0026#39;_type\u0026#39;: \u0026#39;politics\u0026#39;, \u0026#39;_id\u0026#39;: \u0026#39;1\u0026#39;, \u0026#39;_version\u0026#39;: 1, \u0026#39;result\u0026#39;: \u0026#39;created\u0026#39;, \u0026#39;_shards\u0026#39;: {\u0026#39;total\u0026#39;: 2, \u0026#39;successful\u0026#39;: 1, \u0026#39;failed\u0026#39;: 0}, \u0026#39;_seq_no\u0026#39;: 0, \u0026#39;_primary_term\u0026#39;: 1} 结果中 result 字段为 created，代表该数据插入成功。 也可以使用 index() 方法来插入数据，但与 create() 不同的是，create() 方法需要指定 id 字段来唯一标识该条数据，而 index() 方法则不需要，如果不指定 id，会自动生成一个 id，调用 index() 方法的写法如下： es.index(index=\u0026#39;news\u0026#39;, doc_type=\u0026#39;politics\u0026#39;, body=data) create() 方法内部其实也是调用了 index() 方法，是对 index() 方法的封装。 更新数据 更新数据同样需要指定数据的 id 和内容，调用 update() 方法即可，代码如下： from elasticsearch import Elasticsearch es = Elasticsearch() data = { \u0026#39;title\u0026#39;: \u0026#39;美国留给伊拉克的是个烂摊子吗\u0026#39;, \u0026#39;url\u0026#39;: \u0026#39;http://view.news.qq.com/zt2011/usa_iraq/index.htm\u0026#39;, \u0026#39;date\u0026#39;: \u0026#39;2011-12-16\u0026#39; } result = es.update(index=\u0026#39;news\u0026#39;, doc_type=\u0026#39;politics\u0026#39;, body=data, id=1) print(result) 为数据增加了一个日期字段，然后调用了 update() 方法，结果如下： {\u0026#39;_index\u0026#39;: \u0026#39;news\u0026#39;, \u0026#39;_type\u0026#39;: \u0026#39;politics\u0026#39;, \u0026#39;_id\u0026#39;: \u0026#39;1\u0026#39;, \u0026#39;_version\u0026#39;: 2, \u0026#39;result\u0026#39;: \u0026#39;updated\u0026#39;, \u0026#39;_shards\u0026#39;: {\u0026#39;total\u0026#39;: 2, \u0026#39;successful\u0026#39;: 1, \u0026#39;failed\u0026#39;: 0}, \u0026#39;_seq_no\u0026#39;: 1, \u0026#39;_primary_term\u0026#39;: 1} 返回结果中，result 字段为 updated，即表示更新成功，注意字段 _version，这代表更新后的版本号数，2 代表这是第二个版本，因为之前已经插入过一次数据，所以第一次插入的数据是版本 1，可以参见上例的运行结果，这次更新之后版本号就变成了 2，以后每更新一次，版本号都会加 1。 另外更新操作其实利用 index() 方法同样可以做到，写法如下： es.index(index=\u0026#39;news\u0026#39;, doc_type=\u0026#39;politics\u0026#39;, body=data, id=1) index() 方法可以代完成两个操作，如果数据不存在，那就执行插入操作，如果已经存在，那就执行更新操作，非常方便。 删除数据 如果想删除一条数据可以调用 delete() 方法，指定需要删除的数据 id 即可，写法如下： from elasticsearch import Elasticsearch es = Elasticsearch() result = es.delete(index=\u0026#39;news\u0026#39;, doc_type=\u0026#39;politics\u0026#39;, id=1) print(result) 运行结果如下： {\u0026#39;_index\u0026#39;: \u0026#39;news\u0026#39;, \u0026#39;_type\u0026#39;: \u0026#39;politics\u0026#39;, \u0026#39;_id\u0026#39;: \u0026#39;1\u0026#39;, \u0026#39;_version\u0026#39;: 3, \u0026#39;result\u0026#39;: \u0026#39;deleted\u0026#39;, \u0026#39;_shards\u0026#39;: {\u0026#39;total\u0026#39;: 2, \u0026#39;successful\u0026#39;: 1, \u0026#39;failed\u0026#39;: 0}, \u0026#39;_seq_no\u0026#39;: 2, \u0026#39;_primary_term\u0026#39;: 1} 可以看到运行结果中 result 字段为 deleted，代表删除成功，_version 变成了 3，又增加了 1。 查询数据 上面的几个操作都是非常简单的操作，普通的数据库如 MongoDB 都是可以完成的，Elasticsearch 更特殊的地方在于其异常强大的检索功能。 对于中文来说，需要安装一个分词插件，这里使用的是 elasticsearch-analysis-ik，GitHub 链接为：elasticsearch-analysis-ik，这里我们使用 Elasticsearch 的另一个命令行工具 elasticsearch-plugin 来安装，这里安装的版本是 6.2.4，请确保和 Elasticsearch 的版本对应起来，命令如下： elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.2.4/elasticsearch-analysis-ik-6.2.4.zip 这里的版本号请替换成你的 Elasticsearch 的版本号。 安装之后重新启动 Elasticsearch 就可以了，它会自动加载安装好的插件。 首先新建一个索引并指定需要分词的字段，代码如下： from elasticsearch import Elasticsearch es = Elasticsearch() mapping = { \u0026#39;properties\u0026#39;: { \u0026#39;title\u0026#39;: { \u0026#39;type\u0026#39;: \u0026#39;text\u0026#39;, \u0026#39;analyzer\u0026#39;: \u0026#39;ik_max_word\u0026#39;, \u0026#39;search_analyzer\u0026#39;: \u0026#39;ik_max_word\u0026#39; } } } es.indices.delete(index=\u0026#39;news\u0026#39;, ignore=[400, 404]) es.indices.create(index=\u0026#39;news\u0026#39;, ignore=400) result = es.indices.put_mapping(index=\u0026#39;news\u0026#39;, doc_type=\u0026#39;politics\u0026#39;, body=mapping) print(result) 这里先将之前的索引删除了，然后新建了一个索引，然后更新了它的 mapping 信息，mapping 信息中指定了分词的字段，指定了字段的类型 type 为 text，分词器 analyzer 和 搜索分词器 search_analyzer 为 ik_max_word，即使用我们刚才安装的中文分词插件。如果不指定的话则使用默认的英文分词器。 插入几条新的数据： datas = [ { \u0026#39;title\u0026#39;: \u0026#39;美国留给伊拉克的是个烂摊子吗\u0026#39;, \u0026#39;url\u0026#39;: \u0026#39;http://view.news.qq.com/zt2011/usa_iraq/index.htm\u0026#39;, \u0026#39;date\u0026#39;: \u0026#39;2011-12-16\u0026#39; }, { \u0026#39;title\u0026#39;: \u0026#39;公安部：各地校车将享最高路权\u0026#39;, \u0026#39;url\u0026#39;: \u0026#39;http://www.chinanews.com/gn/2011/12-16/3536077.shtml\u0026#39;, \u0026#39;date\u0026#39;: \u0026#39;2011-12-16\u0026#39; }, { \u0026#39;title\u0026#39;: \u0026#39;中韩渔警冲突调查：韩警平均每天扣1艘中国渔船\u0026#39;, \u0026#39;url\u0026#39;: \u0026#39;https://news.qq.com/a/20111216/001044.htm\u0026#39;, \u0026#39;date\u0026#39;: \u0026#39;2011-12-17\u0026#39; }, { \u0026#39;title\u0026#39;: \u0026#39;中国驻洛杉矶领事馆遭亚裔男子枪击 嫌犯已自首\u0026#39;, \u0026#39;url\u0026#39;: \u0026#39;http://news.ifeng.com/world/detail_2011_12/16/11372558_0.shtml\u0026#39;, \u0026#39;date\u0026#39;: \u0026#39;2011-12-18\u0026#39; } ] for data in datas: es.index(index=\u0026#39;news\u0026#39;, doc_type=\u0026#39;politics\u0026#39;, body=data) 指定了四条数据，都带有 title、url、date 字段，然后通过 index() 方法将其插入 Elasticsearch 中，索引名称为 news，类型为 politics。 根据关键词查询一下相关内容： result = es.search(index=\u0026#39;news\u0026#39;, doc_type=\u0026#39;politics\u0026#39;) print(result) 查询出了所有插入的四条数据： { \u0026#34;took\u0026#34;: 0, \u0026#34;timed_out\u0026#34;: false, \u0026#34;_shards\u0026#34;: { \u0026#34;total\u0026#34;: 5, \u0026#34;successful\u0026#34;: 5, \u0026#34;skipped\u0026#34;: 0, \u0026#34;failed\u0026#34;: 0 }, \u0026#34;hits\u0026#34;: { \u0026#34;total\u0026#34;: 4, \u0026#34;max_score\u0026#34;: 1.0, \u0026#34;hits\u0026#34;: [ { \u0026#34;_index\u0026#34;: \u0026#34;news\u0026#34;, \u0026#34;_type\u0026#34;: \u0026#34;politics\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;c05G9mQBD9BuE5fdHOUT\u0026#34;, \u0026#34;_score\u0026#34;: 1.0, \u0026#34;_source\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;美国留给伊拉克的是个烂摊子吗\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;http://view.news.qq.com/zt2011/usa_iraq/index.htm\u0026#34;, \u0026#34;date\u0026#34;: \u0026#34;2011-12-16\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;news\u0026#34;, \u0026#34;_type\u0026#34;: \u0026#34;politics\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;dk5G9mQBD9BuE5fdHOUm\u0026#34;, \u0026#34;_score\u0026#34;: 1.0, \u0026#34;_source\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;中国驻洛杉矶领事馆遭亚裔男子枪击，嫌犯已自首\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;http://news.ifeng.com/world/detail_2011_12/16/11372558_0.shtml\u0026#34;, \u0026#34;date\u0026#34;: \u0026#34;2011-12-18\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;news\u0026#34;, \u0026#34;_type\u0026#34;: \u0026#34;politics\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;dU5G9mQBD9BuE5fdHOUj\u0026#34;, \u0026#34;_score\u0026#34;: 1.0, \u0026#34;_source\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;中韩渔警冲突调查：韩警平均每天扣1艘中国渔船\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://news.qq.com/a/20111216/001044.htm\u0026#34;, \u0026#34;date\u0026#34;: \u0026#34;2011-12-17\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;news\u0026#34;, \u0026#34;_type\u0026#34;: \u0026#34;politics\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;dE5G9mQBD9BuE5fdHOUf\u0026#34;, \u0026#34;_score\u0026#34;: 1.0, \u0026#34;_source\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;公安部：各地校车将享最高路权\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;http://www.chinanews.com/gn/2011/12-16/3536077.shtml\u0026#34;, \u0026#34;date\u0026#34;: \u0026#34;2011-12-16\u0026#34; } } ] } } 返回结果会出现在 hits 字段里面，然后其中有 total 字段标明了查询的结果条目数，还有 max_score 代表了最大匹配分数。 全文检索，Elasticsearch 搜索引擎特性的地方： dsl = { \u0026#39;query\u0026#39;: { \u0026#39;match\u0026#39;: { \u0026#39;title\u0026#39;: \u0026#39;中国 领事馆\u0026#39; } } } es = Elasticsearch() result = es.search(index=\u0026#39;news\u0026#39;, doc_type=\u0026#39;politics\u0026#39;, body=dsl) print(json.dumps(result, indent=2, ensure_ascii=False)) 使用 Elasticsearch 支持的 DSL 语句来进行查询，使用 match 指定全文检索，检索的字段是 title，内容是“中国领事馆”，搜索结果如下： { \u0026#34;took\u0026#34;: 1, \u0026#34;timed_out\u0026#34;: false, \u0026#34;_shards\u0026#34;: { \u0026#34;total\u0026#34;: 5, \u0026#34;successful\u0026#34;: 5, \u0026#34;skipped\u0026#34;: 0, \u0026#34;failed\u0026#34;: 0 }, \u0026#34;hits\u0026#34;: { \u0026#34;total\u0026#34;: 2, \u0026#34;max_score\u0026#34;: 2.546152, \u0026#34;hits\u0026#34;: [ { \u0026#34;_index\u0026#34;: \u0026#34;news\u0026#34;, \u0026#34;_type\u0026#34;: \u0026#34;politics\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;dk5G9mQBD9BuE5fdHOUm\u0026#34;, \u0026#34;_score\u0026#34;: 2.546152, \u0026#34;_source\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;中国驻洛杉矶领事馆遭亚裔男子枪击，嫌犯已自首\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;http://news.ifeng.com/world/detail_2011_12/16/11372558_0.shtml\u0026#34;, \u0026#34;date\u0026#34;: \u0026#34;2011-12-18\u0026#34; } }, { \u0026#34;_index\u0026#34;: \u0026#34;news\u0026#34;, \u0026#34;_type\u0026#34;: \u0026#34;politics\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;dU5G9mQBD9BuE5fdHOUj\u0026#34;, \u0026#34;_score\u0026#34;: 0.2876821, \u0026#34;_source\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;中韩渔警冲突调查：韩警平均每天扣1艘中国渔船\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://news.qq.com/a/20111216/001044.htm\u0026#34;, \u0026#34;date\u0026#34;: \u0026#34;2011-12-17\u0026#34; } } ] } } 匹配的结果有两条，第一条的分数为 2.54，第二条的分数为 0.28，这是因为第一条匹配的数据中含有“中国”和“领事馆”两个词，第二条匹配的数据中不包含“领事馆”，但是包含了“中国”这个词，所以也被检索出来了，但是分数比较低。 检索时会对对应的字段全文检索，结果还会按照检索关键词的相关性进行排序，这就是一个基本的搜索引擎雏形。 Elasticsearch 支持非常多的查询方式，详情可以参考 官方文档 ","permalink":"https://chenzqi.cn/posts/2019/20190610_elasticsearch%E4%BB%8B%E7%BB%8D%E4%B8%8Epython%E5%AE%9E%E7%8E%B0/","tags":["web","python"],"title":"Elasticsearch介绍与Python实现"},{"categories":[2019,"技术"],"contents":":::tip Dockerfile 命令 ::: Dockerfile 指令详解 1 FROM 指定基础镜像 FROM 指令用于指定其后构建新镜像所使用的基础镜像。FROM 指令必是 Dockerfile 文件中的首条命令，启动构建流程后，Docker 将会基于该镜像构建新镜像，FROM 后的命令也会基于这个基础镜像。 FROM语法格式为： FROM \u0026lt;image\u0026gt; OR FROM \u0026lt;image\u0026gt;:\u0026lt;tag\u0026gt; OR FROM \u0026lt;image\u0026gt;:\u0026lt;digest\u0026gt; 通过 FROM 指定的镜像，可以是任何有效的基础镜像。FROM 有以下限制： FROM 必须 是 Dockerfile 中第一条非注释命令 在一个 Dockerfile 文件中创建多个镜像时，FROM 可以多次出现。只需在每个新命令 FROM 之前，记录提交上次的镜像 ID。 tag 或 digest 是可选的，如果不使用这两个值时，会使用 latest 版本的基础镜像 2 RUN 执行命令 在镜像的构建过程中执行特定的命令，并生成一个中间镜像。格式: # shell格式 RUN \u0026lt;command\u0026gt; # exec格式 RUN [\u0026#34;executable\u0026#34;, \u0026#34;param1\u0026#34;, \u0026#34;param2\u0026#34;] RUN 命令将在当前 image 中执行任意合法命令并提交执行结果。命令执行提交后，就会自动执行 Dockerfile 中的下一个指令。 层级 RUN 指令和生成提交是符合 Docker 核心理念的做法。它允许像版本控制那样，在任意一个点，对 image 镜像进行定制化构建。 RUN 指令创建的中间镜像会被缓存，并会在下次构建中使用。如果不想使用这些缓存镜像，可以在构建时指定 \u0026ndash;no-cache 参数，如：docker build \u0026ndash;no-cache。 3 COPY 复制文件 格式： COPY \u0026lt;源路径\u0026gt;... \u0026lt;目标路径\u0026gt; COPY [\u0026#34;\u0026lt;源路径1\u0026gt;\u0026#34;,... \u0026#34;\u0026lt;目标路径\u0026gt;\u0026#34;] 和 RUN 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。COPY 指令将从构建上下文目录中 \u0026lt;源路径\u0026gt; 的文件/目录复制到新的一层的镜像内的\u0026lt;目标路径\u0026gt;位置。比如： COPY package.json /usr/src/app/ \u0026lt;源路径\u0026gt;可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 filepath.Match 规则，如： COPY hom* /mydir/ COPY hom?.txt /mydir/ \u0026lt;目标路径\u0026gt;可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 WORKDIR 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。 此外，还需要注意一点，使用 COPY 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。 4 ADD 更高级的复制文件 ADD 指令和 COPY 的格式和性质基本一致。但是在 COPY 基础上增加了一些功能。比如\u0026lt;源路径\u0026gt;可以是一个 URL，这种情况下，Docker 引擎会试图去下载这个链接的文件放到\u0026lt;目标路径\u0026gt;去。 在构建镜像时，复制上下文中的文件到镜像内，格式： ADD \u0026lt;源路径\u0026gt;... \u0026lt;目标路径\u0026gt; ADD [\u0026#34;\u0026lt;源路径\u0026gt;\u0026#34;,... \u0026#34;\u0026lt;目标路径\u0026gt;\u0026#34;] 注意 如果 docker 发现文件内容被改变，则接下来的指令都不会再使用缓存。关于复制文件时需要处理的/，基本跟正常的 copy 一致 5 ENV 设置环境变量 格式有两种： ENV \u0026lt;key\u0026gt; \u0026lt;value\u0026gt; ENV \u0026lt;key1\u0026gt;=\u0026lt;value1\u0026gt; \u0026lt;key2\u0026gt;=\u0026lt;value2\u0026gt;... 这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 RUN，还是运行时的应用，都可以直接使用这里定义的环境变量。 ENV VERSION=1.0 DEBUG=on \\ NAME=\u0026#34;Happy Feet\u0026#34; 这个例子中演示了如何换行，以及对含有空格的值用双引号括起来的办法，这和 Shell 下的行为是一致的。 6 EXPOSE 为构建的镜像设置监听端口，使容器在运行时监听。格式： EXPOSE \u0026lt;port\u0026gt; [\u0026lt;port\u0026gt;...] EXPOSE 指令并不会让容器监听 host 的端口，如果需要，需要在 docker run 时使用 -p、-P 参数来发布容器端口到 host 的某个端口上。 7 VOLUME 定义匿名卷 VOLUME用于创建挂载点，即向基于所构建镜像创始的容器添加卷： VOLUME [\u0026#34;/data\u0026#34;] 一个卷可以存在于一个或多个容器的指定目录，该目录可以绕过联合文件系统，并具有以下功能： 卷可以容器间共享和重用 容器并不一定要和其它容器共享卷 修改卷后会立即生效 对卷的修改不会对镜像产生影响 卷会一直存在，直到没有任何容器在使用它 VOLUME 让我们可以将源代码、数据或其它内容添加到镜像中，而又不并提交到镜像中，并使我们可以多个容器间共享这些内容。 8 WORKDIR 指定工作目录 WORKDIR用于在容器内设置一个工作目录： WORKDIR /path/to/workdir 通过WORKDIR设置工作目录后，Dockerfile 中其后的命令 RUN、CMD、ENTRYPOINT、ADD、COPY 等命令都会在该目录下执行。 如，使用WORKDIR设置工作目录： WORKDIR /a WORKDIR b WORKDIR c RUN pwd 在以上示例中，pwd 最终将会在 /a/b/c 目录中执行。在使用 docker run 运行容器时，可以通过-w参数覆盖构建时所设置的工作目录。 9 USER 指定当前用户 USER 用于指定运行镜像所使用的用户： USER daemon 使用USER指定用户时，可以使用用户名、UID 或 GID，或是两者的组合。以下都是合法的指定试： USER user USER user:group USER uid USER uid:gid USER user:gid USER uid:group 使用USER指定用户后，Dockerfile 中其后的命令 RUN、CMD、ENTRYPOINT 都将使用该用户。 镜像构建完成后，通过 docker run 运行容器时，可以通过 -u 参数来覆盖所指定的用户。 10 CMD CMD用于指定在容器启动时所要执行的命令。CMD 有以下三种格式： CMD [\u0026#34;executable\u0026#34;,\u0026#34;param1\u0026#34;,\u0026#34;param2\u0026#34;] CMD [\u0026#34;param1\u0026#34;,\u0026#34;param2\u0026#34;] CMD command param1 param2 省略可执行文件的 exec 格式，这种写法使 CMD 中的参数当做 ENTRYPOINT 的默认参数，此时 ENTRYPOINT 也应该是 exec 格式，具体与 ENTRYPOINT 的组合使用，参考 ENTRYPOINT。 注意与 RUN 指令的区别： RUN 在构建的时候执行，并生成一个新的镜像，CMD 在容器运行的时候执行，在构建时不进行任何操作。 11 ENTRYPOINT ENTRYPOINT 用于给容器配置一个可执行程序。也就是说，每次使用镜像创建容器时，通过 ENTRYPOINT 指定的程序都会被设置为默认程序。ENTRYPOINT 有以下两种形式： ENTRYPOINT [\u0026#34;executable\u0026#34;, \u0026#34;param1\u0026#34;, \u0026#34;param2\u0026#34;] ENTRYPOINT command param1 param2 ENTRYPOINT 与 CMD 非常类似，不同的是通过docker run执行的命令不会覆盖 ENTRYPOINT，而docker run命令中指定的任何参数，都会被当做参数再次传递给 ENTRYPOINT。 Dockerfile 中只允许有一个 ENTRYPOINT 命令，多指定时会覆盖前面的设置，而只执行最后的 ENTRYPOINT 指令。 docker run运行容器时指定的参数都会被传递给 ENTRYPOINT ，且会覆盖 CMD 命令指定的参数。 如，执行docker run \u0026lt;image\u0026gt; -d时，-d 参数将被传递给入口点。 也可以通过docker run --entrypoint重写 ENTRYPOINT 入口点。 如：可以像下面这样指定一个容器执行程序： ENTRYPOINT [\u0026#34;/usr/bin/nginx\u0026#34;] 完整构建代码： # Version: 0.0.3 FROM ubuntu:16.04 MAINTAINER 何民三 \u0026#34;cn.liuht@gmail.com\u0026#34; RUN apt-get update RUN apt-get install -y nginx RUN echo \u0026#39;Hello World, 我是个容器\u0026#39; \\ \u0026gt; /var/www/html/index.html ENTRYPOINT [\u0026#34;/usr/sbin/nginx\u0026#34;] EXPOSE 80 使用docker build构建镜像，并将镜像指定为 itbilu/test： docker build -t=\u0026#34;itbilu/test\u0026#34; . 构建完成后，使用itbilu/test启动一个容器： docker run -i -t itbilu/test -g \u0026#34;daemon off;\u0026#34; 在运行容器时，我们使用了 -g \u0026ldquo;daemon off;\u0026quot;，这个参数将会被传递给 ENTRYPOINT，最终在容器中执行的命令为 /usr/sbin/nginx -g \u0026ldquo;daemon off;\u0026quot;。 12 LABEL LABEL用于为镜像添加元数据，元数以键值对的形式指定： LABEL \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; ... 使用LABEL指定元数据时，一条LABEL指定可以指定一或多条元数据，指定多条元数据时不同元数据之间通过空格分隔。推荐将所有的元数据通过一条LABEL指令指定，以免生成过多的中间镜像。 如，通过LABEL指定一些元数据： LABEL version=\u0026#34;1.0\u0026#34; description=\u0026#34;这是一个Web服务器\u0026#34; by=\u0026#34;IT笔录\u0026#34; 指定后可以通过docker inspect查看： docker inspect itbilu/test \u0026#34;Labels\u0026#34;: { \u0026#34;version\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;这是一个Web服务器\u0026#34;, \u0026#34;by\u0026#34;: \u0026#34;IT笔录\u0026#34; }, 13 ARG ARG用于指定传递给构建运行时的变量： ARG \u0026lt;name\u0026gt;[=\u0026lt;default value\u0026gt;] 如，通过ARG指定两个变量： ARG site ARG build_user=IT笔录 以上我们指定了 site 和 build_user 两个变量，其中 build_user 指定了默认值。在使用 docker build 构建镜像时，可以通过 \u0026ndash;build-arg = 参数来指定或重设置这些变量的值。 docker build --build-arg site=itiblu.com -t itbilu/test . 这样我们构建了 itbilu/test 镜像，其中site会被设置为 itbilu.com，由于没有指定 build_user，其值将是默认值 IT 笔录。 14 ONBUILD ONBUILD用于设置镜像触发器： ONBUILD [INSTRUCTION] 当所构建的镜像被用做其它镜像的基础镜像，该镜像中的触发器将会被钥触发。 如，当镜像被使用时，可能需要做一些处理： [...] ONBUILD ADD . /app/src ONBUILD RUN /usr/local/bin/python-build --dir /app/src [...] 15 STOPSIGNAL STOPSIGNAL用于设置停止容器所要发送的系统调用信号： STOPSIGNAL signal 所使用的信号必须是内核系统调用表中的合法的值，如：SIGKILL。 16 SHELL SHELL用于设置执行命令（shell式）所使用的的默认 shell 类型： SHELL [\u0026#34;executable\u0026#34;, \u0026#34;parameters\u0026#34;] SHELL在Windows环境下比较有用，Windows 下通常会有 cmd 和 powershell 两种 shell，可能还会有 sh。这时就可以通过 SHELL 来指定所使用的 shell 类型： FROM microsoft/windowsservercore # Executed as cmd /S /C echo default RUN echo default # Executed as cmd /S /C powershell -command Write-Host default RUN powershell -command Write-Host default # Executed as powershell -command Write-Host hello SHELL [\u0026#34;powershell\u0026#34;, \u0026#34;-command\u0026#34;] RUN Write-Host hello # Executed as cmd /S /C echo hello SHELL [\u0026#34;cmd\u0026#34;, \u0026#34;/S\u0026#34;\u0026#34;, \u0026#34;/C\u0026#34;] RUN echo hello Dockerfile 示例 构建Nginx运行环境 # 指定基础镜像 FROM sameersbn/ubuntu:14.04.20161014 # 维护者信息 MAINTAINER sameer@damagehead.com # 设置环境 ENV RTMP_VERSION=1.1.10 \\ NPS_VERSION=1.11.33.4 \\ LIBAV_VERSION=11.8 \\ NGINX_VERSION=1.10.1 \\ NGINX_USER=www-data \\ NGINX_SITECONF_DIR=/etc/nginx/sites-enabled \\ NGINX_LOG_DIR=/var/log/nginx \\ NGINX_TEMP_DIR=/var/lib/nginx \\ NGINX_SETUP_DIR=/var/cache/nginx # 设置构建时变量，镜像建立完成后就失效 ARG BUILD_LIBAV=false ARG WITH_DEBUG=false ARG WITH_PAGESPEED=true ARG WITH_RTMP=true # 复制本地文件到容器目录中 COPY setup/ ${NGINX_SETUP_DIR}/ RUN bash ${NGINX_SETUP_DIR}/install.sh # 复制本地配置文件到容器目录中 COPY nginx.conf /etc/nginx/nginx.conf COPY entrypoint.sh /sbin/entrypoint.sh # 运行指令 RUN chmod 755 /sbin/entrypoint.sh # 允许指定的端口 EXPOSE 80/tcp 443/tcp 1935/tcp # 指定网站目录挂载点 VOLUME [\u0026#34;${NGINX_SITECONF_DIR}\u0026#34;] ENTRYPOINT [\u0026#34;/sbin/entrypoint.sh\u0026#34;] CMD [\u0026#34;/usr/sbin/nginx\u0026#34;] 构建tomcat 环境 # 指定基于的基础镜像 FROM ubuntu:13.10 # 维护者信息 MAINTAINER zhangjiayang \u0026#34;zhangjiayang@sczq.com.cn\u0026#34; # 镜像的指令操作 # 获取APT更新的资源列表 RUN echo \u0026#34;deb http://archive.ubuntu.com/ubuntu precise main universe\u0026#34;\u0026gt; /etc/apt/sources.list # 更新软件 RUN apt-get update # Install curl RUN apt-get -y install curl # Install JDK 7 RUN cd /tmp \u0026amp;\u0026amp; curl -L \u0026#39;http://download.oracle.com/otn-pub/java/jdk/7u65-b17/jdk-7u65-linux-x64.tar.gz\u0026#39; -H \u0026#39;Cookie: oraclelicense=accept-securebackup-cookie; gpw_e24=Dockerfile\u0026#39; | tar -xz RUN mkdir -p /usr/lib/jvm RUN mv /tmp/jdk1.7.0_65/ /usr/lib/jvm/java-7-oracle/ # Set Oracle JDK 7 as default Java RUN update-alternatives --install /usr/bin/java java /usr/lib/jvm/java-7-oracle/bin/java 300 RUN update-alternatives --install /usr/bin/javac javac /usr/lib/jvm/java-7-oracle/bin/javac 300 # 设置系统环境 ENV JAVA_HOME /usr/lib/jvm/java-7-oracle/ # Install tomcat7 RUN cd /tmp \u0026amp;\u0026amp; curl -L \u0026#39;http://archive.apache.org/dist/tomcat/tomcat-7/v7.0.8/bin/apache-tomcat-7.0.8.tar.gz\u0026#39; | tar -xz RUN mv /tmp/apache-tomcat-7.0.8/ /opt/tomcat7/ ENV CATALINA_HOME /opt/tomcat7 ENV PATH $PATH:$CATALINA_HOME/bin # 复件tomcat7.sh到容器中的目录 ADD tomcat7.sh /etc/init.d/tomcat7 RUN chmod 755 /etc/init.d/tomcat7 # Expose ports. 指定暴露的端口 EXPOSE 8080 # Define default command. ENTRYPOINT service tomcat7 start \u0026amp;\u0026amp; tail -f /opt/tomcat7/logs/catalina.out 结尾 容器轻量化。从镜像中产生的容器应该尽量轻量化，能在足够短的时间内停止、销毁、重新生成并替换原来的容器。 使用 .gitignore。在大部分情况下，Dockerfile 会和构建所需的文件放在同一个目录中，为了提高构建的性能，应该使用 .gitignore 来过滤掉不需要的文件和目录。 为了减少镜像的大小，减少依赖，仅安装需要的软件包。 一个容器只做一件事。解耦复杂的应用，分成多个容器，而不是所有东西都放在一个容器内运行。如一个 Python Web 应用，可能需要 Server、DB、Cache、MQ、Log 等几个容器。一个更加极端的说法：One process per container。 减少镜像的图层。不要多个 Label、ENV 等标签。 对续行的参数按照字母表排序，特别是使用apt-get install -y安装包的时候。 使用构建缓存。如果不想使用缓存，可以在构建的时候使用参数\u0026ndash;no-cache=true来强制重新生成中间镜像。 ","permalink":"https://chenzqi.cn/posts/2019/20190605_dockerfile-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/","tags":["Docker","记录"],"title":"Dockerfile 命令记录"},{"categories":[2019,"技术"],"contents":"准备工作 安装seleniumm pip install selenium 下载浏览器驱动 Firefox浏览器驱动：geckodriver Chrome浏览器驱动：chromedriver , taobao备用地址 IE浏览器驱动：IEDriverServer Edge浏览器驱动：MicrosoftWebDriver Opera浏览器驱动：operadriver PhantomJS浏览器驱动：phantomjs 需要把浏览器驱动放入系统路径中，或者直接告知selenuim的驱动路径 启动浏览器，可以设置一些参数，比如无界面之类的，详细参考：配置参数 可以测试是否正常使用: from selenium import webdriver driver = webdriver.Firefox() # Firefox浏览器 # driver = webdriver.Firefox(\u0026#34;驱动路径\u0026#34;) driver = webdriver.Chrome() # Chrome浏览器 driver = webdriver.Ie() # Internet Explorer浏览器 driver = webdriver.Edge() # Edge浏览器 driver = webdriver.Opera() # Opera浏览器 driver = webdriver.PhantomJS() # PhantomJS 元素定位 find_element_by_id() find_element_by_name() find_element_by_class_name() find_element_by_tag_name() find_element_by_link_text() find_element_by_partial_link_text() find_element_by_xpath() find_element_by_css_selector() 在element变成elements就是找所有满足的条件，返回数组。 控制浏览器操作 控制浏览器窗口大小 driver.set_window_size(480, 800) 后退 driver.back() 前进 driver.forward() 刷新 driver.refresh() Webelement常用方法 点击和输入 driver.find_element_by_id(\u0026#34;kw\u0026#34;).clear() # 清除文本 driver.find_element_by_id(\u0026#34;kw\u0026#34;).send_keys(\u0026#34;selenium\u0026#34;) # 模拟按键输入 driver.find_element_by_id(\u0026#34;su\u0026#34;).click() # 单机元素 提交 可以在搜索框模拟回车操作 search_text = driver.find_element_by_id(\u0026#39;kw\u0026#39;) search_text.send_keys(\u0026#39;selenium\u0026#39;) search_text.submit() 其他 size: 返回元素的尺寸。 text: 获取元素的文本。 get_attribute(name): 获得属性值。 is_displayed(): 设置该元素是否用户可见。 鼠标操作 在 WebDriver 中， 将这些关于鼠标操作的方法封装在 ActionChains 类提供。 ActionChains 类提供了鼠标操作的常用方法： perform()： 执行所有 ActionChains 中存储的行为； context_click()： 右击； double_click()： 双击； drag_and_drop()： 拖动； move_to_element()：鼠标悬停。 举个例子： from selenium import webdriver # 引入 ActionChains 类 from selenium.webdriver.common.action_chains import ActionChains driver = webdriver.Chrome() driver.get(\u0026#34;https://www.baidu.cn\u0026#34;) # 定位到要悬停的元素 above = driver.find_element_by_link_text(\u0026#34;设置\u0026#34;) # 对定位到的元素执行鼠标悬停操作 ActionChains(driver).move_to_element(above).perform() 键盘事件 以下为常用的键盘操作： send_keys(Keys.BACK_SPACE) 删除键（BackSpace） send_keys(Keys.SPACE) 空格键(Space) send_keys(Keys.TAB) 制表键(Tab) send_keys(Keys.ESCAPE) 回退键（Esc） send_keys(Keys.ENTER) 回车键（Enter） send_keys(Keys.CONTROL,\u0026#39;a\u0026#39;) 全选（Ctrl+A） send_keys(Keys.CONTROL,\u0026#39;c\u0026#39;) 复制（Ctrl+C） send_keys(Keys.CONTROL,\u0026#39;x\u0026#39;) 剪切（Ctrl+X） send_keys(Keys.CONTROL,\u0026#39;v\u0026#39;) 粘贴（Ctrl+V） send_keys(Keys.F1) 键盘 F1 send_keys(Keys.F12) 键盘 F12 # 输入框输入内容 driver.find_element_by_id(\u0026#34;kw\u0026#34;).send_keys(\u0026#34;seleniumm\u0026#34;) # 删除多输入的一个 m driver.find_element_by_id(\u0026#34;kw\u0026#34;).send_keys(Keys.BACK_SPACE) 获取断言信息 title = driver.title # 打印当前页面title now_url = driver.current_url # 打印当前页面URL user = driver.find_element_by_class_name(\u0026#39;nums\u0026#39;).text # 获取结果数目 等待页面加载完成 显性等待 显式等待使WebdDriver等待某个条件成立时继续执行，否则在达到最大时长时抛出超时异常（TimeoutException）。 from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC driver = webdriver.Firefox() driver.get(\u0026#34;http://www.baidu.com\u0026#34;) element = WebDriverWait(driver, 5, 0.5).until( EC.presence_of_element_located((By.ID, \u0026#34;kw\u0026#34;)) ) element.send_keys(\u0026#39;selenium\u0026#39;) driver.quit() WebDriverWait类是由WebDirver 提供的等待方法。在设置时间内，默认每隔一段时间检测一次当前页面元素是否存在，如果超过设置时间检测不到则抛出异常。具体格式如下： WebDriverWait(driver, timeout, poll_frequency=0.5, ignored_exceptions=None) driver：浏览器驱动。 timeout：最长超时时间，默认以秒为单位。 poll_frequency：检测的间隔（步长）时间，默认为0.5S。 ignored_exceptions：超时后的异常信息，默认情况下抛NoSuchElementException异常。 WebDriverWait()：一般由until()或until_not()方法配合使用 下面是until()和until_not()方法的说明 until(method, message=‘’) 调用该方法提供的驱动程序作为一个参数，直到返回值为True。 until_not(method, message=‘’) 调用该方法提供的驱动程序作为一个参数，直到返回值为False。 在本例中，通过as关键字将expected_conditions 重命名为EC，并调用**presence_of_element_located()**方法判断元素是否存在。 隐式等待 如果某些元素不是立即可用的，隐式等待是告诉WebDriver去等待一定的时间后去查找元素。 默认等待时间是0秒，一旦设置该值，隐式等待是设置该WebDriver的实例的生命周期。 from selenium import webdriver driver = webdriver.Firefox() driver.implicitly_wait(10) # seconds driver.get(\u0026#34;http://somedomain/url_that_delays_loading\u0026#34;) myDynamicElement = driver.find_element_by_id(\u0026#34;myDynamicElement\u0026#34;) 在不同的窗口和框架之间移动 driver.switch_to_window(\u0026#34;windowName\u0026#34;) driver.switch_to_frame(\u0026#34;frameName\u0026#34;) 以直接取表单的id 或name属性。如果iframe没有可用的id和name属性，则可以通过下面的方式进行定位。 #先通过xpth定位到iframe xf = driver.find_element_by_xpath(\u0026#39;//*[@id=\u0026#34;x-URS-iframe\u0026#34;]\u0026#39;) #再将定位对象传给switch_to_frame()方法 driver.switch_to_frame(xf) 一旦我们完成了frame中的工作，我们可以这样返回父frame: driver.switch_to_default_content() 警告框处理 alert = driver.switch_to_alert() text：返回 alert/confirm/prompt 中的文字信息。 accept()：接受现有警告框。 dismiss()：解散现有警告框。 send_keys(keysToSend)：发送文本至警告框。keysToSend：将文本发送至警告框。 下拉框选择 from selenium import webdriver from selenium.webdriver.support.select import Select from time import sleep driver = webdriver.Chrome() driver.implicitly_wait(10) driver.get(\u0026#39;http://www.baidu.com\u0026#39;) sel = driver.find_element_by_xpath(\u0026#34;//select[@id=\u0026#39;nr\u0026#39;]\u0026#34;) Select(sel).select_by_value(\u0026#39;50\u0026#39;) # 显示50条 文件上传 # 定位上传按钮，添加本地文件 driver.find_element_by_name(\u0026#34;file\u0026#34;).send_keys(\u0026#39;D:\\\\upload_file.txt\u0026#39;) cookie操作 WebDriver操作cookie的方法： get_cookies()： 获得所有cookie信息。 get_cookie(name)： 返回字典的key为“name”的cookie信息。 add_cookie(cookie_dict) ： 添加cookie。“cookie_dict”指字典对象，必须有name 和value 值。 delete_cookie(name,optionsString)：删除cookie信息。“name”是要删除的cookie的名称，“optionsString”是该cookie的选项，目前支持的选项包括“路径”，“域”。 delete_all_cookies()： 删除所有cookie信息 调用JavaScript代码 通过**execute_script()**方法执行JavaScripts代码来移动滚动条的位置。 js=\u0026#34;window.scrollTo(100,450);\u0026#34; driver.execute_script(js) # 通过javascript设置浏览器窗口的滚动条位置 窗口截图 driver.get_screenshot_as_file(\u0026#34;D:\\\\baidu_img.jpg\u0026#34;) # 截取当前窗口，并指定截图图片的保存位置 关闭浏览器 close() 关闭单个窗口 quit() 关闭所有窗口 直接用cookie登录方法 手动获取网页的cookie，将其序列化并存储在本地 写入代码 for item in cookies: driver.add_cookie(item) ","permalink":"https://chenzqi.cn/posts/2019/20190530_selenium-python-%E8%87%AA%E5%8A%A8%E5%8C%96/","tags":["python","工具"],"title":"Selenium Python 自动化"},{"categories":[2019,"技术"],"contents":":::tip selenium配置 ::: 每次当selenium启动chrome浏览器的时候，chrome浏览器很干净，没有插件、没有收藏、没有历史记录，这是因为selenium在启动chrome时为了保证最快的运行效率，启动了一个裸浏览器，这就是为什么需要配置参数的原因，但是有些时候我们需要的不仅是一个裸浏览器。 selenium启动配置参数接收是ChromeOptions类，创建方式如下： from selenium import webdriver option = webdriver.ChromeOptions() 创建了ChromeOptions类之后就是添加参数，添加参数有几个特定的方法，分别对应添加不同类型的配置项目。 设置 chrome 二进制文件位置 (binary_location) from selenium import webdriver option = webdriver.ChromeOptions() # 添加启动参数 option.add_argument() # 添加扩展应用 option.add_extension() option.add_encoded_extension() # 添加实验性质的设置参数 option.add_experimental_option() # 设置调试器地址 option.debugger_address() 常用配置参数 from selenium import webdriver option = webdriver.ChromeOptions() # 添加UA options.add_argument(\u0026#39;user-agent=\u0026#34;MQQBrowser/26 Mozilla/5.0 (Linux; U; Android 2.3.7; zh-cn; MB200 Build/GRJ22; CyanogenMod-7) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1\u0026#34;\u0026#39;) # 指定浏览器分辨率 options.add_argument(\u0026#39;window-size=1920x3000\u0026#39;) # 谷歌文档提到需要加上这个属性来规避bug chrome_options.add_argument(\u0026#39;--disable-gpu\u0026#39;) # 隐藏滚动条, 应对一些特殊页面 options.add_argument(\u0026#39;--hide-scrollbars\u0026#39;) # 不加载图片, 提升速度 options.add_argument(\u0026#39;blink-settings=imagesEnabled=false\u0026#39;) # 浏览器不提供可视化页面. linux下如果系统不支持可视化不加这条会启动失败 options.add_argument(\u0026#39;--headless\u0026#39;) # 以最高权限运行 options.add_argument(\u0026#39;--no-sandbox\u0026#39;) # 手动指定使用的浏览器位置 options.binary_location = r\u0026#34;C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe\u0026#34; #添加crx插件 option.add_extension(\u0026#39;d:\\crx\\AdBlock_v2.17.crx\u0026#39;) # 禁用JavaScript option.add_argument(\u0026#34;--disable-javascript\u0026#34;) # 设置开发者模式启动，该模式下webdriver属性为正常值 options.add_experimental_option(\u0026#39;excludeSwitches\u0026#39;, [\u0026#39;enable-automation\u0026#39;]) # 禁用浏览器弹窗 prefs = { \u0026#39;profile.default_content_setting_values\u0026#39; : { \u0026#39;notifications\u0026#39; : 2 } } options.add_experimental_option(\u0026#39;prefs\u0026#39;,prefs) driver=webdriver.Chrome(chrome_options=chrome_options) 浏览器地址栏参数 在浏览器地址栏输入下列命令得到相应的信息 about:version - 显示当前版本 about:memory - 显示本机浏览器内存使用状况 about:plugins - 显示已安装插件 about:histograms - 显示历史记录 about:dns - 显示DNS状态 about:cache - 显示缓存页面 about:gpu -是否有硬件加速 chrome://extensions/ - 查看已经安装的扩展 其他配置项目参数 –user-data-dir=”[PATH]” # 指定用户文件夹User Data路径，可以把书签这样的用户数据保存在系统分区以外的分区 –disk-cache-dir=”[PATH]“ # 指定缓存Cache路径 –disk-cache-size= # 指定Cache大小，单位Byte –first run # 重置到初始状态，第一次运行 –incognito # 隐身模式启动 –disable-javascript # 禁用Javascript --omnibox-popup-count=\u0026#34;num\u0026#34; # 将地址栏弹出的提示菜单数量改为num个 --user-agent=\u0026#34;xxxxxxxx\u0026#34; # 修改HTTP请求头部的Agent字符串，可以通过about:version页面查看修改效果 --disable-plugins # 禁止加载所有插件，可以增加速度。可以通过about:plugins页面查看效果 --disable-javascript # 禁用JavaScript，如果觉得速度慢在加上这个 --disable-java # 禁用java --start-maximized # 启动就最大化 --no-sandbox # 取消沙盒模式 --single-process # 单进程运行 --process-per-tab # 每个标签使用单独进程 --process-per-site # 每个站点使用单独进程 --in-process-plugins # 插件不启用单独进程 --disable-popup-blocking # 禁用弹出拦截 --disable-plugins # 禁用插件 --disable-images # 禁用图像 --incognito # 启动进入隐身模式 --enable-udd-profiles # 启用账户切换菜单 --proxy-pac-url # 使用pac代理 [via 1/2] --lang=zh-CN # 设置语言为简体中文 --disk-cache-dir # 自定义缓存目录 --disk-cache-size # 自定义缓存最大值（单位byte） --media-cache-size # 自定义多媒体缓存最大值（单位byte） --bookmark-menu # 在工具 栏增加一个书签按钮 --enable-sync # 启用书签同步 ","permalink":"https://chenzqi.cn/posts/2019/20190530_selenium%E5%90%AF%E5%8A%A8chrome%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0/","tags":["python","工具"],"title":"selenium启动Chrome配置参数"},{"categories":[2019,"技术"],"contents":"实例 算术运算和文件写入的例子 def process(num1, num2, file): result = num1 / num2 with open(file, \u0026#39;w\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: f.write(str(result)) 定义了一个 process 方法，接收三个参数，前两个参数是 num1 和 num2，第三个参数是 file。方法会首先将 num1 除以 num2，然后把除法的结果写入到 file 文件里面。 这个实现的漏洞： 没有判断 num1、num2 的类型，如果不是数字类型，那会抛出 TypeError。 没有判断 num2 是不是 0，如果是 0，那么会抛出 ZeroDivisionError。 没有判断文件路径是否存在，如果是子文件夹下的路径，文件夹不存在的话，会抛出 FileNotFoundError。 一些异常测试用例如下： process(1, 2, \u0026#39;result/result.txt\u0026#39;) process(1, 0, \u0026#39;result.txt\u0026#39;) process(1, [2], \u0026#39;result.txt\u0026#39;) 用例跑起来一定会报错 最好的方式是通过一些判断条件把一些该处理的问题和判定都加上 def process(num1, num2, file): try: result = num1 / num2 with open(file, \u0026#39;w\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: f.write(str(result)) except ZeroDivisionError: print(f\u0026#39;{num2} can not be zero\u0026#39;) except FileNotFoundError: print(f\u0026#39;file {file} not found\u0026#39;) except Exception as e: print(f\u0026#39;exception, {e.args}\u0026#39;) 问题: 代码一下子臃肿了起来，这里的异常处理都没有实现，仅仅是 print 了一些错误信息，但现在可以看到异常处理代码可能比主逻辑还要多 主逻辑代码整块被硬生生地缩进进去了，如果主逻辑代码比较多的话，那么会有大片大片的缩进 如果再有相同的逻辑的代码，要再写一次 try except 几种改善的方案： 本身这个场景不需要这么多异常处理，使用判断条件把一些意外情况处理掉就好 异常处理本身就不应该这么写，每个功能区域应该和异常处理单独分开，另外各个逻辑模块建议再分方法解耦 使用 retrying 模块检测异常并进行重试。 使用上下文管理器 raise_api_error 来声明异常处理。 但上面的一些解决方案其实还不能彻底解决代码复用和美观上的问题，比如某一类的异常处理就统一在一个地方处理，另外任何代码都不想因为异常处理产生缩进。 Merry库 Merry库是 Python 的一个第三方库，非常小巧，实现了几个装饰器。通过使用 Merry 我们可以把异常检查和异常处理的代码分开，并可以通过装饰器来定义异常检查和处理的逻辑。 安装 pip3 install merry 使用 from merry import Merry merry = Merry() merry.logger.disabled = True @merry._try def process(num1, num2, file): result = num1 / num2 with open(file, \u0026#39;w\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: f.write(str(result)) @merry._except(ZeroDivisionError) def process_zero_division_error(e): print(\u0026#39;zero_division_error\u0026#39;, e) @merry._except(FileNotFoundError) def process_file_not_found_error(e): print(\u0026#39;file_not_found_error\u0026#39;, e) @merry._except(Exception) def process_exception(e): print(\u0026#39;exception\u0026#39;, type(e), e) if __name__ == \u0026#39;__main__\u0026#39;: process(1, 2, \u0026#39;result/result.txt\u0026#39;) process(1, 0, \u0026#39;result.txt\u0026#39;) process(1, 2, \u0026#39;result.txt\u0026#39;) process(1, [1], \u0026#39;result.txt\u0026#39;) 可以看到，我们首先声明了一个 Merry 对象，然后 process 方法加上 merry 对象的 _try 方法的装饰器，这样就实现了异常的监听。 有了异常监听之后，怎么来进行异常处理呢？还是通过同一个 merry 对象，使用其 _except 方法作为装饰器即可。比如这里我们将几个异常处理方法分开了，如处理 ZeroDivisionError、FileNotFoundError、Exception 等异常分别都有一个方法的声明，分别加上对应的装饰器即可。 这样的话，就轻松实现了异常监听和处理 和上面不同之处： 主逻辑里面不用额外加异常处理代码了，显得简洁。 主逻辑不用因为 try except 而缩进了。 每个异常处理方法单独分开了，可以实现解耦和重用。 整个实现就舒服多了。 运行一下上面的代码，输出结果如下： file_not_found_error [Errno 2] No such file or directory: \u0026#39;result/result.txt\u0026#39; zero_division_error division by zero exception \u0026lt;class \u0026#39;TypeError\u0026#39;\u0026gt; unsupported operand type(s) for /: \u0026#39;int\u0026#39; and \u0026#39;list\u0026#39; 类实现 上面的实现整个看起来结构比较松散，代码不好复用 如果封装好了类之后，可以直接把类拿过来使用，实现的时候继承这个类，就不用再关心各个异常处理是怎么实现的了。 在这里一个简单的实现如下： import requests from merry import Merry from requests import ConnectTimeout merry = Merry() merry.logger.disabled = True catch = merry._try class BaseClass(object): @staticmethod @merry._except(ZeroDivisionError) def process_zero_division_error(e): print(\u0026#39;zero_division_error\u0026#39;, e) @staticmethod @merry._except(FileNotFoundError) def process_file_not_found_error(e): print(\u0026#39;file_not_found_error\u0026#39;, e) @staticmethod @merry._except(Exception) def process_exception(e): print(\u0026#39;exception\u0026#39;, type(e), e) @staticmethod @merry._except(ConnectTimeout) def process_connect_timeout(e): print(\u0026#39;connect_timeout\u0026#39;, e) class Calculator(BaseClass): @catch def process(self, num1, num2, file): result = num1 / num2 with open(file, \u0026#39;w\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: f.write(str(result)) class Fetcher(BaseClass): @catch def process(self, url): response = requests.get(url, timeout=1) if response.status_code == 200: print(response.text) if __name__ == \u0026#39;__main__\u0026#39;: c = Calculator() c.process(1, 0, \u0026#39;result.txt\u0026#39;) f = Fetcher() f.process(\u0026#39;http://notfound.com\u0026#39;) 先实现了一个 BaseClass，里面通过 merry 定义了好多个异常处理方法和处理流程，异常处理方法定义成 staticmethod。 接着定义了两个类，一个是 Calculator，一个是 Fetcher，分别完成不同的功能，一个是计算，一个是抓取网页。另外 Merry 的 _try 方法我们给它取了个别名，比如叫做 catch，显得更简洁。 在 process 方法中，我们我们想要进行异常处理，那么就加上 @catch 这装饰器就好了，其他的不需要管。 这样，在实现子类的时候，只需要集成 BaseClass 然后实现对应的方法就好了，如果想加上异常处理就加个装饰器，也无需再关心 Merry 的具体实现，父类都实现好了. 运行结果如下： zero_division_error division by zero connect_timeout HTTPConnectionPool(host=\u0026#39;notfound.com\u0026#39;, port=80): Max retries exceeded with url: / (Caused by ConnectTimeoutError(\u0026lt;urllib3.connection.HTTPConnection object at 0x10d5b9310\u0026gt;, \u0026#39;Connection to notfound.com timed out. (connect timeout=1)\u0026#39;)) 数据传递 利用 try except 可以直接获取异常代码的变量信息，分了方法之后，一些上下文的变量不就拿不到了 Merry 是用了一个全局的变量来解决的，它使用了 merry.g 这个对象来存储上下文的变量，在 主逻辑方法里面要把想要传递的参数赋值进去，在异常处理的方法里面再用 merry.g 取出来，官方示例写法如下： @merry._try def app_logic(): db = open_database() merry.g.database = db # save it in the error context just in case # do database stuff here @merry._except(Exception) def catch_all(): db = getattr(merry.g, \u0026#39;database\u0026#39;, None) if db is not None and is_database_open(db): close_database(db) print(\u0026#39;Unexpected error, quitting\u0026#39;) sys.exit(1) 源码剖析 from functools import wraps import inspect import logging getargspec = None if getattr(inspect, \u0026#39;getfullargspec\u0026#39;, None): getargspec = inspect.getfullargspec else: # this one is deprecated in Python 3, but available in Python 2 getargspec = inspect.getargspec class _Namespace: pass class Merry(object): def __init__(self, logger_name=\u0026#39;merry\u0026#39;, debug=False): self.logger = logging.getLogger(logger_name) self.g = _Namespace() self.debug = debug self.except_ = {} self.force_debug = [] self.force_handle = [] self.else_ = None self.finally_ = None def _try(self, f): @wraps(f) def wrapper(*args, **kwargs): ret = None try: ret = f(*args, **kwargs) # note that if the function returned something, the else clause # will be skipped. This is a similar behavior to a normal # try/except/else block. if ret is not None: return ret except Exception as e: # find the best handler for this exception handler = None for c in self.except_.keys(): if isinstance(e, c): if handler is None or issubclass(c, handler): handler = c # if we don\u0026#39;t have any handler, we let the exception bubble up if handler is None: raise e # log exception self.logger.exception(\u0026#39;[merry] Exception caught\u0026#39;) # if in debug mode, then bubble up to let a debugger handle debug = self.debug if handler in self.force_debug: debug = True elif handler in self.force_handle: debug = False if debug: raise e # invoke handler if len(getargspec(self.except_[handler])[0]) == 0: return self.except_[handler]() else: return self.except_[handler](e) else: # if we have an else handler, call it now if self.else_ is not None: return self.else_() finally: # if we have a finally handler, call it now if self.finally_ is not None: alt_ret = self.finally_() if alt_ret is not None: ret = alt_ret return ret return wrapper def _except(self, *args, **kwargs): def decorator(f): for e in args: self.except_[e] = f d = kwargs.get(\u0026#39;debug\u0026#39;, None) if d: self.force_debug.append(e) elif d is not None: self.force_handle.append(e) return f return decorator def _else(self, f): self.else_ = f return f def _finally(self, f): self.finally_ = f return f 主要的逻辑都在 _try 方法里面了，就是仿照这标准的 try、except、else、finally 方法把流程实现下来了，只不过在对应的逻辑区块里面调用了装饰器修饰的方法。 其中有一个地方比较有意思： handler = None for c in self.except_.keys(): if isinstance(e, c): if handler is None or issubclass(c, handler): handler = c 这里是为异常处理找寻一个最佳的异常处理方法，可以看到这里通过各个 _except 修饰的方法，然后通过 issubclass 方法来找寻最小能处理的子类，最终找到最佳匹配方法. ","permalink":"https://chenzqi.cn/posts/2019/20190521_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%BA%93merry/","tags":["python"],"title":"异常处理库merry的用法"},{"categories":[2019,"技术"],"contents":":::tip PyQt5编程 ::: 工具 记录为公司人员写的便携操作数据库房源数据程序, UI与逻辑层分离，使用 Qt Designer + PyQt5完成。pycharm配置PyUIC工具（ui转py工具）。 UI代码 # -*- coding: utf-8 -*- # Form implementation generated from reading ui file \u0026#39;pyqt5_demo.ui\u0026#39; # # Created by: PyQt5 UI code generator 5.15.0 # # WARNING: Any manual changes made to this file will be lost when pyuic5 is # run again. Do not edit this file unless you know what you are doing. from PyQt5 import QtCore, QtGui, QtWidgets class Ui_MainWindow(object): def setupUi(self, MainWindow): MainWindow.setObjectName(\u0026#34;MainWindow\u0026#34;) MainWindow.resize(944, 633) self.centralwidget = QtWidgets.QWidget(MainWindow) self.centralwidget.setObjectName(\u0026#34;centralwidget\u0026#34;) self.export_button = QtWidgets.QPushButton(self.centralwidget) self.export_button.setGeometry(QtCore.QRect(810, 240, 80, 30)) font = QtGui.QFont() font.setFamily(\u0026#34;Microsoft YaHei UI\u0026#34;) font.setPointSize(12) self.export_button.setFont(font) self.export_button.setStyleSheet(\u0026#34;\u0026#34;) self.export_button.setIconSize(QtCore.QSize(22, 22)) self.export_button.setObjectName(\u0026#34;export_button\u0026#34;) self.select_button = QtWidgets.QPushButton(self.centralwidget) self.select_button.setGeometry(QtCore.QRect(690, 240, 80, 30)) font = QtGui.QFont() font.setFamily(\u0026#34;微软雅黑\u0026#34;) font.setPointSize(12) font.setBold(False) font.setItalic(False) font.setWeight(50) self.select_button.setFont(font) self.select_button.setStyleSheet(\u0026#34;background-color:rgb(85, 170, 127);\\n\u0026#34; \u0026#34;font: 12pt \\\u0026#34;微软雅黑\\\u0026#34;;\\n\u0026#34; \u0026#34;border-radius:3px;\u0026#34;) self.select_button.setIconSize(QtCore.QSize(22, 22)) self.select_button.setAutoRepeat(False) self.select_button.setAutoDefault(False) self.select_button.setDefault(False) self.select_button.setFlat(False) self.select_button.setObjectName(\u0026#34;select_button\u0026#34;) self.groupBox = QtWidgets.QGroupBox(self.centralwidget) self.groupBox.setGeometry(QtCore.QRect(560, 0, 381, 171)) self.groupBox.setStyleSheet(\u0026#34;background-color:#dbfcff\u0026#34;) self.groupBox.setTitle(\u0026#34;\u0026#34;) self.groupBox.setObjectName(\u0026#34;groupBox\u0026#34;) self.label_6 = QtWidgets.QLabel(self.groupBox) self.label_6.setGeometry(QtCore.QRect(253, 90, 110, 20)) font = QtGui.QFont() font.setFamily(\u0026#34;MV Boli\u0026#34;) self.label_6.setFont(font) self.label_6.setObjectName(\u0026#34;label_6\u0026#34;) self.date_name = QtWidgets.QLineEdit(self.groupBox) self.date_name.setGeometry(QtCore.QRect(80, 82, 140, 30)) font = QtGui.QFont() font.setFamily(\u0026#34;微软雅黑\u0026#34;) font.setPointSize(10) self.date_name.setFont(font) self.date_name.setStyleSheet(\u0026#34;background-color:#ffffff;\\n\u0026#34; \u0026#34;border-radius:3px;\u0026#34;) self.date_name.setObjectName(\u0026#34;date_name\u0026#34;) self.city_name = QtWidgets.QComboBox(self.groupBox) self.city_name.setGeometry(QtCore.QRect(250, 20, 91, 31)) font = QtGui.QFont() font.setFamily(\u0026#34;Microsoft YaHei UI\u0026#34;) font.setPointSize(10) self.city_name.setFont(font) self.city_name.setStyleSheet(\u0026#34;background-color:#ffffff;\\n\u0026#34; \u0026#34;border-radius:3px;\u0026#34;) self.city_name.setObjectName(\u0026#34;city_name\u0026#34;) self.city_name.addItem(\u0026#34;\u0026#34;) self.city_name.addItem(\u0026#34;\u0026#34;) self.city_name.addItem(\u0026#34;\u0026#34;) self.city_name.addItem(\u0026#34;\u0026#34;) self.city_name.addItem(\u0026#34;\u0026#34;) self.city_name.addItem(\u0026#34;\u0026#34;) self.city_name.addItem(\u0026#34;\u0026#34;) self.city_name.addItem(\u0026#34;\u0026#34;) self.label_2 = QtWidgets.QLabel(self.groupBox) self.label_2.setGeometry(QtCore.QRect(200, 20, 41, 31)) font = QtGui.QFont() font.setFamily(\u0026#34;微软雅黑\u0026#34;) font.setPointSize(12) font.setBold(False) font.setWeight(50) self.label_2.setFont(font) self.label_2.setObjectName(\u0026#34;label_2\u0026#34;) self.label_5 = QtWidgets.QLabel(self.groupBox) self.label_5.setGeometry(QtCore.QRect(30, 81, 41, 30)) font = QtGui.QFont() font.setFamily(\u0026#34;微软雅黑\u0026#34;) font.setPointSize(12) font.setBold(False) font.setWeight(50) self.label_5.setFont(font) self.label_5.setObjectName(\u0026#34;label_5\u0026#34;) self.label = QtWidgets.QLabel(self.groupBox) self.label.setGeometry(QtCore.QRect(30, 20, 41, 31)) font = QtGui.QFont() font.setFamily(\u0026#34;微软雅黑\u0026#34;) font.setPointSize(12) font.setBold(False) font.setWeight(50) self.label.setFont(font) self.label.setObjectName(\u0026#34;label\u0026#34;) self.status_name = QtWidgets.QComboBox(self.groupBox) self.status_name.setGeometry(QtCore.QRect(80, 20, 91, 31)) font = QtGui.QFont() font.setFamily(\u0026#34;Microsoft YaHei UI\u0026#34;) font.setPointSize(10) self.status_name.setFont(font) self.status_name.setStyleSheet(\u0026#34;background-color:#ffffff;\\n\u0026#34; \u0026#34;border-radius:3px;\u0026#34;) self.status_name.setObjectName(\u0026#34;status_name\u0026#34;) self.status_name.addItem(\u0026#34;\u0026#34;) self.status_name.addItem(\u0026#34;\u0026#34;) self.status_name.addItem(\u0026#34;\u0026#34;) self.status_name.addItem(\u0026#34;\u0026#34;) self.status_name.addItem(\u0026#34;\u0026#34;) self.status_name.addItem(\u0026#34;\u0026#34;) self.tableView = QtWidgets.QTableView(self.centralwidget) self.tableView.setGeometry(QtCore.QRect(0, 30, 560, 560)) font = QtGui.QFont() font.setFamily(\u0026#34;微软雅黑\u0026#34;) font.setPointSize(10) self.tableView.setFont(font) self.tableView.setStyleSheet(\u0026#34;background-color:#f6f8fa;\\n\u0026#34; \u0026#34;border-radius:5px;\u0026#34;) self.tableView.setObjectName(\u0026#34;tableView\u0026#34;) self.tableView.horizontalHeader().setVisible(True) self.tableView.horizontalHeader().setCascadingSectionResizes(False) self.textBrowser = QtWidgets.QTextBrowser(self.centralwidget) self.textBrowser.setGeometry(QtCore.QRect(562, 480, 380, 110)) font = QtGui.QFont() font.setFamily(\u0026#34;微软雅黑\u0026#34;) font.setPointSize(10) self.textBrowser.setFont(font) self.textBrowser.setObjectName(\u0026#34;textBrowser\u0026#34;) self.groupBox_2 = QtWidgets.QGroupBox(self.centralwidget) self.groupBox_2.setGeometry(QtCore.QRect(0, 0, 560, 31)) self.groupBox_2.setStyleSheet(\u0026#34;background-color:#55aa7f;\u0026#34;) self.groupBox_2.setTitle(\u0026#34;\u0026#34;) self.groupBox_2.setObjectName(\u0026#34;groupBox_2\u0026#34;) self.label_4 = QtWidgets.QLabel(self.groupBox_2) self.label_4.setGeometry(QtCore.QRect(240, 6, 80, 20)) font = QtGui.QFont() font.setFamily(\u0026#34;微软雅黑\u0026#34;) font.setPointSize(12) font.setBold(False) font.setWeight(50) self.label_4.setFont(font) self.label_4.setObjectName(\u0026#34;label_4\u0026#34;) self.groupBox_3 = QtWidgets.QGroupBox(self.centralwidget) self.groupBox_3.setGeometry(QtCore.QRect(562, 450, 380, 31)) self.groupBox_3.setStyleSheet(\u0026#34;background-color:#55aa7f;\u0026#34;) self.groupBox_3.setTitle(\u0026#34;\u0026#34;) self.groupBox_3.setObjectName(\u0026#34;groupBox_3\u0026#34;) self.label_7 = QtWidgets.QLabel(self.groupBox_3) self.label_7.setGeometry(QtCore.QRect(160, 3, 80, 20)) font = QtGui.QFont() font.setFamily(\u0026#34;微软雅黑\u0026#34;) font.setPointSize(12) font.setBold(False) font.setWeight(50) self.label_7.setFont(font) self.label_7.setObjectName(\u0026#34;label_7\u0026#34;) MainWindow.setCentralWidget(self.centralwidget) self.menubar = QtWidgets.QMenuBar(MainWindow) self.menubar.setGeometry(QtCore.QRect(0, 0, 944, 23)) self.menubar.setObjectName(\u0026#34;menubar\u0026#34;) self.menu = QtWidgets.QMenu(self.menubar) self.menu.setObjectName(\u0026#34;menu\u0026#34;) MainWindow.setMenuBar(self.menubar) self.statusbar = QtWidgets.QStatusBar(MainWindow) self.statusbar.setObjectName(\u0026#34;statusbar\u0026#34;) MainWindow.setStatusBar(self.statusbar) self.action1 = QtWidgets.QAction(MainWindow) self.action1.setObjectName(\u0026#34;action1\u0026#34;) self.actionhelle1 = QtWidgets.QAction(MainWindow) self.actionhelle1.setCheckable(True) font = QtGui.QFont() font.setFamily(\u0026#34;Microsoft YaHei UI\u0026#34;) font.setPointSize(12) font.setBold(False) font.setWeight(50) font.setStyleStrategy(QtGui.QFont.PreferDefault) self.actionhelle1.setFont(font) self.actionhelle1.setObjectName(\u0026#34;actionhelle1\u0026#34;) self.actionhello2 = QtWidgets.QAction(MainWindow) font = QtGui.QFont() font.setFamily(\u0026#34;Microsoft YaHei UI\u0026#34;) font.setPointSize(11) self.actionhello2.setFont(font) self.actionhello2.setObjectName(\u0026#34;actionhello2\u0026#34;) self.menu.addAction(self.actionhelle1) self.menu.addAction(self.actionhello2) self.menubar.addAction(self.menu.menuAction()) self.retranslateUi(MainWindow) QtCore.QMetaObject.connectSlotsByName(MainWindow) def retranslateUi(self, MainWindow): _translate = QtCore.QCoreApplication.translate MainWindow.setWindowTitle(_translate(\u0026#34;MainWindow\u0026#34;, \u0026#34;房源查询（融易拍）\u0026#34;)) self.export_button.setText(_translate(\u0026#34;MainWindow\u0026#34;, \u0026#34;导出\u0026#34;)) self.select_button.setText(_translate(\u0026#34;MainWindow\u0026#34;, \u0026#34;搜索\u0026#34;)) self.label_6.setText(_translate(\u0026#34;MainWindow\u0026#34;, \u0026#34;示例：2020/01/01\u0026#34;)) self.city_name.setItemText(0, _translate(\u0026#34;MainWindow\u0026#34;, \u0026#34;全部\u0026#34;)) self.city_name.setItemText(1, _translate(\u0026#34;MainWindow\u0026#34;, \u0026#34;罗湖\u0026#34;)) self.city_name.setItemText(2, _translate(\u0026#34;MainWindow\u0026#34;, \u0026#34;福田\u0026#34;)) self.city_name.setItemText(3, _translate(\u0026#34;MainWindow\u0026#34;, \u0026#34;南山\u0026#34;)) self.city_name.setItemText(4, _translate(\u0026#34;MainWindow\u0026#34;, \u0026#34;宝安\u0026#34;)) self.city_name.setItemText(5, _translate(\u0026#34;MainWindow\u0026#34;, \u0026#34;龙岗\u0026#34;)) self.city_name.setItemText(6, _translate(\u0026#34;MainWindow\u0026#34;, \u0026#34;盐田\u0026#34;)) self.city_name.setItemText(7, _translate(\u0026#34;MainWindow\u0026#34;, \u0026#34;龙华\u0026#34;)) self.label_2.setText(_translate(\u0026#34;MainWindow\u0026#34;, \u0026#34;区域\u0026#34;)) self.label_5.setText(_translate(\u0026#34;MainWindow\u0026#34;, \u0026#34;时间\u0026#34;)) self.label.setText(_translate(\u0026#34;MainWindow\u0026#34;, \u0026#34;状态\u0026#34;)) self.status_name.setItemText(0, _translate(\u0026#34;MainWindow\u0026#34;, \u0026#34;全部\u0026#34;)) self.status_name.setItemText(1, _translate(\u0026#34;MainWindow\u0026#34;, \u0026#34;正在竞拍\u0026#34;)) self.status_name.setItemText(2, _translate(\u0026#34;MainWindow\u0026#34;, \u0026#34;即将开始\u0026#34;)) self.status_name.setItemText(3, _translate(\u0026#34;MainWindow\u0026#34;, \u0026#34;流拍\u0026#34;)) self.status_name.setItemText(4, _translate(\u0026#34;MainWindow\u0026#34;, \u0026#34;撤拍\u0026#34;)) self.status_name.setItemText(5, _translate(\u0026#34;MainWindow\u0026#34;, \u0026#34;成交\u0026#34;)) self.label_4.setText(_translate(\u0026#34;MainWindow\u0026#34;, \u0026#34;结果输出\u0026#34;)) self.label_7.setText(_translate(\u0026#34;MainWindow\u0026#34;, \u0026#34;日志输出框\u0026#34;)) self.menu.setTitle(_translate(\u0026#34;MainWindow\u0026#34;, \u0026#34;菜单\u0026#34;)) self.action1.setText(_translate(\u0026#34;MainWindow\u0026#34;, \u0026#34;1\u0026#34;)) self.actionhelle1.setText(_translate(\u0026#34;MainWindow\u0026#34;, \u0026#34;helle1\u0026#34;)) self.actionhello2.setText(_translate(\u0026#34;MainWindow\u0026#34;, \u0026#34;hello2\u0026#34;)) 逻辑层 #!/usr/bin/env python # -*- coding:utf-8 -*- \u0026#34;\u0026#34;\u0026#34; @file: call_pyqt5_demo.py @desc: None @Author: Chenzq @Wechat: 15690833097 @contact: czq181020@gmail.com \u0026#34;\u0026#34;\u0026#34; import PyQt5.sip # 导入程序运行必须模块 import sys, os from threading import Thread from time import strftime, localtime, time if hasattr(sys, \u0026#39;frozen\u0026#39;): os.environ[\u0026#39;PATH\u0026#39;] = sys._MEIPASS + \u0026#39;;\u0026#39; + os.environ[\u0026#39;PATH\u0026#39;] # PyQt5中使用的基本控件都在PyQt5.QtWidgets模块中 from PyQt5.QtWidgets import QApplication, QMainWindow, QDialog, QMessageBox from PyQt5.QtGui import QStandardItemModel, QStandardItem from pandas import DataFrame, ExcelWriter from pymysql import connect # 导入designer工具生成的login模块 from pyqt5_demo import Ui_MainWindow class MyMainForm(QMainWindow, Ui_MainWindow, QDialog): def __init__(self, parent=None): super(MyMainForm, self).__init__(parent) self.setupUi(self) # 链接数据库 self.db = connect( host=\u0026#39;127.0.0.1\u0026#39;, port=3306, user=\u0026#39;root\u0026#39;, passwd=\u0026#39;123456\u0026#39;, db=\u0026#39;dbname\u0026#39;, charset=\u0026#39;utf8\u0026#39; ) self.cursor = self.db.cursor() # 添加登录按钮信号和槽。注意display函数不加小括号() self.select_button.clicked.connect(self.display) # 添加退出按钮信号和槽。调用close函数 self.export_button.clicked.connect(self._export_excel) # 筛选房源状态 self.status = \u0026#39;\u0026#39; # 刷选房源区域 self.city = \u0026#39;\u0026#39; # 刷选房源日期 self.date = \u0026#39;\u0026#39; self.datas = [] def display(self): # 利用line Edit控件对象text()函数获取界面输入 # username = self.lineEdit.text() # password = self.lineEdit_2.text() self.status = self.status_name.currentText() self.city = self.city_name.currentText() self.date = self.date_name.text() t = Thread(target=self._select) t.setDaemon(True) t.start() # self._select() def _select(self): # 查询 self.export_log(msg=\u0026#39;状态：\u0026#39; + self.status + \u0026#39;，\u0026#39; + \u0026#39;区域：\u0026#39; + self.city + \u0026#39;，\u0026#39; + \u0026#39;日期：\u0026#39; + self.date) if not self.date: self.date = \u0026#39;0\u0026#39; if not all([self.status, self.city]): self.export_log(\u0026#39;时间与区域不能为空?\u0026#39;) v_dict = { \u0026#34;statusName\u0026#34;: repr(self.status), \u0026#34;countyName\u0026#34;: repr(self.city), } if self.status == \u0026#39;全部\u0026#39; and self.city == \u0026#39;全部\u0026#39;: check_sql = \u0026#34;\u0026#34;\u0026#34; SELECT countyName,statusName,startTime,buildingName,areaSize,currentPrice,startPrice,unitPrice, communityName,bTypeName,taxesName,fzID, jiaofu, biz_tag FROM houselist WHERE startTime LIKE \u0026#39;%{}%\u0026#39; ORDER BY editDate DESC \u0026#34;\u0026#34;\u0026#34;.format(self.date) elif self.status == \u0026#39;全部\u0026#39; and self.city != \u0026#39;全部\u0026#39;: check_sql = \u0026#34;\u0026#34;\u0026#34; SELECT countyName,statusName,startTime,buildingName,areaSize,currentPrice,startPrice,unitPrice, communityName,bTypeName,taxesName,fzID,jiaofu, biz_tag FROM houselist WHERE countyName={} AND startTime LIKE \u0026#39;%{}%\u0026#39; ORDER BY editDate DESC \u0026#34;\u0026#34;\u0026#34;.format(v_dict.get(\u0026#39;countyName\u0026#39;), self.date) elif self.status != \u0026#39;全部\u0026#39; and self.city == \u0026#39;全部\u0026#39;: check_sql = \u0026#34;\u0026#34;\u0026#34; SELECT countyName,statusName,startTime,buildingName,areaSize,currentPrice,startPrice,unitPrice, communityName,bTypeName,taxesName,fzID,jiaofu, biz_tag FROM houselist WHERE statusName={} AND startTime LIKE \u0026#39;%{}%\u0026#39; ORDER BY editDate DESC \u0026#34;\u0026#34;\u0026#34;.format(v_dict.get(\u0026#39;statusName\u0026#39;), self.date) elif self.status != \u0026#39;全部\u0026#39; and self.city != \u0026#39;全部\u0026#39;: check_sql = \u0026#34;\u0026#34;\u0026#34; SELECT countyName,statusName,startTime,buildingName,areaSize,currentPrice,startPrice,unitPrice, communityName,bTypeName,taxesName,fzID,jiaofu, biz_tag FROM houselist WHERE statusName={} AND countyName={} AND startTime LIKE \u0026#39;%{}%\u0026#39; ORDER BY editDate DESC \u0026#34;\u0026#34;\u0026#34;.format(v_dict.get(\u0026#39;statusName\u0026#39;), v_dict.get(\u0026#39;countyName\u0026#39;), self.date) try: self.cursor.execute(check_sql) self.datas = self.cursor.fetchall() except Exception as e: print(e) self.export_log(msg=\u0026#39;请尝试退出重启?\u0026#39;) else: global data_dict data_dict = { \u0026#34;区域\u0026#34;: [], \u0026#34;开始时间\u0026#34;: [], \u0026#34;标的物\u0026#34;: [], \u0026#34;面积\u0026#34;: [], \u0026#34;㎡\u0026#34;: [], \u0026#34;起拍\u0026#34;: [], \u0026#34;当前价\u0026#34;: [], \u0026#34;学区\u0026#34;: [], \u0026#34;板块\u0026#34;: [], \u0026#34;市场\u0026#34;: [], \u0026#34;市场价\u0026#34;: [], \u0026#34;折扣率\u0026#34;: [], \u0026#34;清场交付\u0026#34;: [], \u0026#34;均价\u0026#34;: [], \u0026#34;URL\u0026#34;: [], # \u0026#34;类型\u0026#34;: [], # \u0026#34;状态\u0026#34;: [], # \u0026#34;评估价\u0026#34;: [], # \u0026#34;小区\u0026#34;: [], # \u0026#34;税费\u0026#34;: [], } url = \u0026#34;https://www.51paimaifang.com/detail/{}.html\u0026#34; ali = \u0026#34;https://sf-item.taobao.com/sf_item/{}.htm\u0026#34; jd = \u0026#34;https://paimai.jd.com/{}\u0026#34; self.model = QStandardItemModel(len(self.datas), 3) # 设置表头 self.model.setHorizontalHeaderLabels([\u0026#39;区域\u0026#39;, \u0026#39;小区\u0026#39;, \u0026#39;标的物\u0026#39;]) for row, data in enumerate(self.datas): data_dict.get(\u0026#39;区域\u0026#39;).append(data[0]) data_dict.get(\u0026#39;开始时间\u0026#39;).append(data[2]) data_dict.get(\u0026#39;标的物\u0026#39;).append(data[3]) data_dict.get(\u0026#39;面积\u0026#39;).append(data[4]) data_dict.get(\u0026#39;㎡\u0026#39;).append(\u0026#39;㎡\u0026#39;) data_dict.get(\u0026#39;起拍\u0026#39;).append(\u0026#39;起拍\u0026#39;) data_dict.get(\u0026#39;当前价\u0026#39;).append(data[5]) data_dict.get(\u0026#39;学区\u0026#39;).append(\u0026#39; \u0026#39;) data_dict.get(\u0026#39;板块\u0026#39;).append(data[13]) data_dict.get(\u0026#39;市场\u0026#39;).append(\u0026#39;市场\u0026#39;) data_dict.get(\u0026#39;市场价\u0026#39;).append(\u0026#39; \u0026#39;) data_dict.get(\u0026#39;折扣率\u0026#39;).append(\u0026#39; \u0026#39;) data_dict.get(\u0026#39;清场交付\u0026#39;).append(data[12]) data_dict.get(\u0026#39;均价\u0026#39;).append(data[7]) fzID = data[11] house_id = fzID[-1] if house_id == \u0026#39;1\u0026#39;: data_dict.get(\u0026#39;URL\u0026#39;).append(ali.format(fzID[:-1])) elif house_id == \u0026#39;2\u0026#39;: data_dict.get(\u0026#39;URL\u0026#39;).append(jd.format(fzID[:-1])) else: data_dict.get(\u0026#39;URL\u0026#39;).append(url.format(data[11])) # data_dict.get(\u0026#39;类型\u0026#39;).append(data[9]) # data_dict.get(\u0026#39;状态\u0026#39;).append(data[1]) # data_dict.get(\u0026#39;评估价\u0026#39;).append(data[6]) # data_dict.get(\u0026#39;小区\u0026#39;).append(data[8]) # data_dict.get(\u0026#39;税费\u0026#39;).append(data[10]) for column in range(0, 3): if column == 0: val = data[0] if column == 1: val = data[8] if column == 2: val = data[3] item = QStandardItem(val) # 设置每个位置的文本值 self.model.setItem(row, column, item) # 水平方向标签拓展剩下的窗口部分，填满表格 self.tableView.horizontalHeader().setStretchLastSection(True) # 水平方向，表格大小拓展到适当的尺寸 # self.tableView.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch) # 关联QTableView控件和Model self.tableView.setModel(self.model) self.export_log(\u0026#39;结果共：\u0026#39; + str(len(self.datas)) + \u0026#39;条\u0026#39;) def _export_excel(self): # 导出搜索结果 try: isinstance(data_dict, dict) except NameError as e: self.export_log(msg=\u0026#39;无查询结果\u0026#39;) else: if data_dict: # urls = data_dict.get(\u0026#39;URL\u0026#39;) # for url in urls: # r = url.rsplit(\u0026#39;/\u0026#39;) # print(r) # try: today_time = strftime(\u0026#39;%Y-%m-%d\u0026#39;, localtime(time())) df1 = DataFrame(data_dict) writer = ExcelWriter(self.city + \u0026#39;\u0026amp;\u0026#39; + self.status + today_time + \u0026#39;.xlsx\u0026#39;) df1.to_excel(writer, sheet_name=\u0026#39;Data1\u0026#39;, startcol=0, index=False) writer.save() self.export_log(msg=\u0026#39;文件名 \u0026#39; + self.city + \u0026#39;\u0026amp;\u0026#39; + self.status + today_time + \u0026#39;.xlsx\u0026#39;) except PermissionError as e: self.export_log(msg=\u0026#39;请关闭 \u0026#39; + self.city + \u0026#39;\u0026amp;\u0026#39; + self.status + today_time + \u0026#39;.xlsx\u0026#39;) else: self.export_log(msg=\u0026#39;无结果\u0026#39;) self.export_log(msg=\u0026#39;导出完成\u0026#39;) def closeEvent(self, event): \u0026#34;\u0026#34;\u0026#34; 重写closeEvent方法，实现dialog窗体关闭时执行一些代码 :param event: close()触发的事件 :return: None \u0026#34;\u0026#34;\u0026#34; reply = QMessageBox.question(self, \u0026#39;关闭程序\u0026#39;, \u0026#34;是否要退出程序？\u0026#34;, QMessageBox.Yes | QMessageBox.No, QMessageBox.No) if reply == QMessageBox.Yes: self.cursor.close() self.db.close() self.export_log(msg=\u0026#39;断开数据库\u0026#39;) event.accept() else: event.ignore() def export_log(self, msg): # 利用text Browser控件对象setText()函数设置界面显示,append追加输出数据 self.textBrowser.append(msg) if __name__ == \u0026#34;__main__\u0026#34;: # 固定的，PyQt5程序都需要QApplication对象。sys.argv是命令行参数列表，确保程序可以双击运行 app = QApplication(sys.argv) # 初始化 myWin = MyMainForm() # 设置窗口logo图标 # myWin.setWindowIcon(QIcon(\u0026#39;fangzi.ico\u0026#39;)) # 将窗口控件显示在屏幕上 myWin.show() # 程序运行，sys.exit方法确保程序完整退出。 sys.exit(app.exec_()) 示例图 ","permalink":"https://chenzqi.cn/posts/2019/20190515_pyqt5%E6%A1%8C%E9%9D%A2%E7%A8%8B%E5%BA%8F%E8%AE%B0%E5%BD%95/","tags":["记录"],"title":"PyQt5桌面程序记录"},{"categories":[2019,"技术"],"contents":"RYP有限公司 Flask workon flaskvir [root@izwz94gdegum84cnrx9rtoz ~]# cd pythoncode/mysqlinit [root@izwz94gdegum84cnrx9rtoz mysqlinit]# pwd /root/pythoncode/mysqlinit [root@izwz94gdegum84cnrx9rtoz mysqlinit]# ls dump.rdb infos logs manage.py migrations __pycache__ requirements.txt utils [root@izwz94gdegum84cnrx9rtoz mysqlinit]# ps -ef | grep gunicorn root 4319 1 0 Nov18 ? 00:01:39 /root/.env/flaskvir/bin/python3.7 /root/.env/flaskvir/bin/gunicorn -w 20 -b 0.0.0.0:5000 manage:app root 4726 4319 0 Nov18 ? 00:00:21 /root/.env/flaskvir/bin/python3.7 /root/.env/flaskvir/bin/gunicorn -w 20 -b 0.0.0.0:5000 manage:app [root@izwz94gdegum84cnrx9rtoz mysqlinit]# kill PID [root@izwz94gdegum84cnrx9rtoz mysqlinit]# nohup gunicorn -w 20 -b 0.0.0.0:5000 manage:app \u0026gt;/dev/null 2\u0026gt;\u0026amp;1 \u0026amp; 图片CDN8081 lsof -i:8081 [root@izwz94gdegum84cnrx9rtoz static]# pwd /root/pythoncode/mysqlinit/infos/static [root@izwz94gdegum84cnrx9rtoz static]# ls css dist imgs js pifu.zip xlsx [root@izwz94gdegum84cnrx9rtoz static]# nohup live-server --host=0.0.0.0 --port=8081 \u0026gt;/dev/null 2\u0026gt;\u0026amp;1 \u0026amp; 注册邀请页面8080 lsof -i:8080 [root@izwz94gdegum84cnrx9rtoz niu]# pwd /root/pythoncode/HTMLshare/niu [root@izwz94gdegum84cnrx9rtoz niu]# ls bak index.html nohup.out static [root@izwz94gdegum84cnrx9rtoz niu]# nohup live-server --host=0.0.0.0 --port=8080 \u0026gt;/dev/null 2\u0026gt;\u0026amp;1 \u0026amp; Redis nohup redis-server \u0026gt;/dev/null 2\u0026gt;\u0026amp;1 \u0026amp; 后台管理 nginx 配置 proxy_set_header Host $host:$server_port; 启动前终止 ps -ef | grep rypsystem kill PID (flask_ryp) [root@iZm5eab8t820b0vmpk5557Z rypadmin]# pwd /root/www/rypadmin (flask_ryp) [root@iZm5eab8t820b0vmpk5557Z rypadmin]# nohup java -jar -Xms2000m -Xmx2000m rypsystem-0.0.1-SNAPSHOT.jar --server.port=8081 \u0026amp; ","permalink":"https://chenzqi.cn/posts/2019/20190502_%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/","tags":["记录"],"title":"服务器项目命令记录"},{"categories":[2019,"技术"],"contents":":::tip Redis搭建爬虫代理IP池 ::: # -*- coding: utf-8 -*- \u0026#34;\u0026#34;\u0026#34; @file: proxy.py @desc: 爬虫IP代理池 @Author: Chenzq @Wechat: 15690833097 @contact: czq181020@gmail.com \u0026#34;\u0026#34;\u0026#34; import json import requests import redis import datetime, time from taobao_sale.settings import (REDIS_HOST, REDIS_PORT, REDIS_PASSWORD, PROXY_POOL_COUNT, PROXY_PULL_COUNT, PROXY_URL) class RedisClient(object): def __init__(self, host=REDIS_HOST, port=REDIS_PORT): if REDIS_PASSWORD: self._db = redis.StrictRedis(host=host, port=port, password=REDIS_PASSWORD) else: # pool = redis.ConnectionPool(host=host, port=port, decode_responses=True) self._db = redis.StrictRedis(host=host, port=port, db=0) def get(self): \u0026#34;\u0026#34;\u0026#34; get proxies from redis self._db.ttl(\u0026#39;http://111.126.76.119:4583\u0026#39;) 查看过期时间 \u0026#34;\u0026#34;\u0026#34; if int(len(self._db.keys())) \u0026lt; PROXY_POOL_COUNT: self.put() # proxie = random.choice(list(self._db.smembers(\u0026#34;proxies\u0026#34;))) proxie = str(self._db.randomkey(), encoding=\u0026#34;utf-8\u0026#34;) return proxie def put(self): \u0026#34;\u0026#34;\u0026#34; add proxy to right top \u0026#34;\u0026#34;\u0026#34; result = requests.get(url=PROXY_URL % (str(PROXY_PULL_COUNT))) rst = json.loads(result.text) datas = rst.get(\u0026#34;data\u0026#34;) if datas: for data in datas: current_time = datetime.datetime.now().strftime(\u0026#34;%Y-%m-%d %H:%M:%S\u0026#34;) expire_time = data.get(\u0026#34;expire_time\u0026#34;) proxie = \u0026#34;http://\u0026#34; + str(data.get(\u0026#39;ip\u0026#39;)) + \u0026#39;:\u0026#39; + str(data.get(\u0026#39;port\u0026#39;)) current_time = int(time.mktime(time.strptime(current_time, \u0026#34;%Y-%m-%d %H:%M:%S\u0026#34;))) expire_time = int(time.mktime(time.strptime(expire_time, \u0026#34;%Y-%m-%d %H:%M:%S\u0026#34;))) expire_time = expire_time - (current_time + 30) # print(\u0026#39;过期秒数\u0026#39;, expire_time) # new_proxie_list.append(proxie) self._db.setex(name=proxie, value=1, time=expire_time) print(\u0026#39;add proxies successful\u0026#39;) else: print(\u0026#39;调用代理失败：\u0026#39;, rst.get(\u0026#34;msg\u0026#34;)) def dele(self, proxie): \u0026#34;\u0026#34;\u0026#34; del proxy from right. \u0026#34;\u0026#34;\u0026#34; dele_rest = self._db.delete(proxie) if dele_rest: print(dele_rest, proxie) pass proxie = self.get() return proxie # @property def queue_len(self): \u0026#34;\u0026#34;\u0026#34; get length from queue. \u0026#34;\u0026#34;\u0026#34; return self._db.scard(\u0026#34;proxies\u0026#34;) def flush(self): \u0026#34;\u0026#34;\u0026#34; flush db \u0026#34;\u0026#34;\u0026#34; self._db.flushall() def tttl(self, proxie): expire_time = self._db.ttl(proxie) return expire_time if __name__ == \u0026#39;__main__\u0026#39;: conn = RedisClient() # conn.get() # outtime = conn.tttl(get) # print(outtime) # conn.dele(get) # conn.flush() ","permalink":"https://chenzqi.cn/posts/2019/20190425_redis%E4%BB%A3%E7%90%86ip%E6%B1%A0/","tags":["爬虫"],"title":"Redis代理IP池"},{"categories":[2019,"技术"],"contents":"步骤 使用 Fiddler 抓取公众号接口数据 使用 Python 脚本获取公众号所有历史文章数据 保存历史文章 Fiddler 抓包 使用微信桌面客户端，打开某个公众号的历史文章，这里以我的公众号举例，如下图。 fiddler 配置没问题，能够看到如下图的数据 图中包含抓取的 url、一些重要的参数和我们想要的数据。 这些参数中，offset 控制着翻页，其他参数在每一页中都是固定不变的。 接口返回的数据结构如下图，其中 can_msg_continue 字段控制着能否翻页，1 表示还有下一页，0 表示没有已经是最后一页了。 next_offset 字段就是下一次请求的 offset 参数 构造请求，获取数据 使用 pdfkit 将 文章 url 保存为 pdf 文件；另一种是先保存 html 文件，然后将 html 制作成 chm 文件。保存为 pdf 文件，用到了 python 的第三方库 pdfkit 和 wkhtmltopdf 安装第三方工具包 安装 pdfkit： pip install pdfkit 安装 wkhtmltopdf 下载地址 程序 #!/usr/bin/env python # -*- coding:utf-8 -*- import time, json import pdfkit, requests index = 0 can_msg_continue = 1 file_name = \u0026#39;公众号PDF数据\u0026#39; __biz = \u0026#39;\u0026#39; uin = \u0026#39;\u0026#39; key = \u0026#39;\u0026#39; def parse(): global index print(\u0026#39;第 %s 页\u0026#39; % (index)) # url前缀 url = \u0026#34;https://mp.weixin.qq.com/mp/profile_ext\u0026#34; # 请求头 headers = { \u0026#34;User-Agent\u0026#34;: \u0026#34;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 \u0026#34; \u0026#34;Safari/537.36 MicroMessenger/6.5.2.501 NetType/WIFI WindowsWechat QBCore/3.43.901.400 \u0026#34; \u0026#34;QQBrowser/9.0.2524.400\u0026#34;, } proxies = { \u0026#39;https\u0026#39;: None, \u0026#39;http\u0026#39;: None, } # 重要参数 param = { \u0026#39;action\u0026#39;: \u0026#39;getmsg\u0026#39;, \u0026#39;__biz\u0026#39;: __biz, \u0026#39;f\u0026#39;: \u0026#39;json\u0026#39;, \u0026#39;offset\u0026#39;: index * 10, \u0026#39;count\u0026#39;: \u0026#39;10\u0026#39;, \u0026#39;is_ok\u0026#39;: \u0026#39;1\u0026#39;, \u0026#39;scene\u0026#39;: \u0026#39;124\u0026#39;, \u0026#39;uin\u0026#39;: uin, \u0026#39;key\u0026#39;: key, \u0026#39;wxtoken\u0026#39;: \u0026#39;\u0026#39;, \u0026#39;x5\u0026#39;: \u0026#39;0\u0026#39;, } # 发送请求，获取响应 response = requests.get(url, headers=headers, params=param, proxies=proxies) response_dict = response.json() next_offset = response_dict[\u0026#39;next_offset\u0026#39;] can_msg_continue = response_dict[\u0026#39;can_msg_continue\u0026#39;] general_msg_list = response_dict[\u0026#39;general_msg_list\u0026#39;] data_list = json.loads(general_msg_list)[\u0026#39;list\u0026#39;] for data in data_list: # 文章发布时间 datetime = data[\u0026#39;comm_msg_info\u0026#39;][\u0026#39;datetime\u0026#39;] date = time.strftime(\u0026#39;%Y-%m-%d\u0026#39;, time.localtime(datetime)) try: msg_info = data.get(\u0026#39;app_msg_ext_info\u0026#39;) msg_list = msg_info.get(\u0026#39;multi_app_msg_item_list\u0026#39;) except Exception as e: print(\u0026#34;ERRMSG:::\u0026#34;, e) else: # 文章标题 title = msg_info[\u0026#39;title\u0026#39;] # 文章链接 url = msg_info[\u0026#39;content_url\u0026#39;] options = { \u0026#39;page-size\u0026#39;: \u0026#39;A4\u0026#39;, \u0026#39;margin-top\u0026#39;: \u0026#39;0mm\u0026#39;, \u0026#39;margin-right\u0026#39;: \u0026#39;0mm\u0026#39;, \u0026#39;margin-bottom\u0026#39;: \u0026#39;0mm\u0026#39;, \u0026#39;margin-left\u0026#39;: \u0026#39;0mm\u0026#39;, # \u0026#39;orientation\u0026#39;:\u0026#39;Landscape\u0026#39;,#横向 \u0026#39;encoding\u0026#39;: \u0026#34;UTF-8\u0026#34;, \u0026#39;no-outline\u0026#39;: None, # \u0026#39;footer-right\u0026#39;:\u0026#39;[page]\u0026#39; 设置页码 } try: # 设置wkhtmltopdf的路径 config = pdfkit.configuration(wkhtmltopdf=\u0026#39;D:\\\\Program Files\\wkhtmltopdf\\\\bin\\\\wkhtmltopdf.exe\u0026#39;) # 自己定义存储路径（绝对路径） pdfkit.from_url(url, \u0026#39;E:/service/数据文件/\u0026#39; + file_name + \u0026#39;/\u0026#39; + date + title + \u0026#39;.pdf\u0026#39;, configuration=config) except Exception as e: print(\u0026#39;ERRMSG:::\u0026#39;, e) print(\u0026#34;不是图文消息\u0026#34;) else: print(date + title + \u0026#39;成功\u0026#39;) # if msg_list: for data in msg_list: title = data[\u0026#39;title\u0026#39;] url = data[\u0026#39;content_url\u0026#39;] try: # 设置wkhtmltopdf的路径 config = pdfkit.configuration(wkhtmltopdf=\u0026#39;D:\\\\Program Files\\wkhtmltopdf\\\\bin\\\\wkhtmltopdf.exe\u0026#39;) # 自己定义存储路径（绝对路径） pdfkit.from_url(url, \u0026#39;E:/service/数据文件/\u0026#39; + file_name + \u0026#39;/\u0026#39; + date + title + \u0026#39;.pdf\u0026#39;, configuration=config) except Exception as e: print(\u0026#39;ERRMSG:::\u0026#39;, e) print(\u0026#34;不是图文消息\u0026#34;) else: print(date + title + \u0026#39;成功\u0026#39;) if can_msg_continue == 1: index += 1 parse() pass else: print(\u0026#39;第 %s 页爬取完毕\u0026#39; % (index)) return False 效果 ","permalink":"https://chenzqi.cn/posts/2019/20190420_python%E7%88%AC%E5%8F%96%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0/","tags":["爬虫"],"title":"爬取微信公众号文章"},{"categories":[2019,"技术"],"contents":"::: warning Windows下编辑shell脚本编码问题 在windows下编辑的文件远程传送到linux下的时候每行末尾都会出现^M，这将导致shell脚本运行错误，主要是因为dos下的编辑器和linux下的编辑器对文件末行的回车符处理不一致导致。 ::: 解决方案 第一种 sed -i 's/\\r//' filename.sh 第二种 vim filename.sh 命令模式下 set ff 如果输出 fileformat=dos 在命令模式下 set ff=unix ","permalink":"https://chenzqi.cn/posts/2019/20190406_windows%E4%B8%8B%E7%BC%96%E8%BE%91shell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/","tags":["问题"],"title":"Windows下编辑shell脚本编码问题"},{"categories":[2019,"技术"],"contents":"pipelines.py class MysqlPipeline(): def __init__(self, host, database, user, password, port): self.host = host self.database = database self.user = user self.password = password self.port = port @classmethod def from_crawler(cls, crawler): return cls( host=crawler.settings.get(\u0026#39;MYSQL_HOST\u0026#39;), database=crawler.settings.get(\u0026#39;MYSQL_DATABASE\u0026#39;), user=crawler.settings.get(\u0026#39;MYSQL_USER\u0026#39;), password=crawler.settings.get(\u0026#39;MYSQL_PASSWORD\u0026#39;), port=crawler.settings.get(\u0026#39;MYSQL_PORT\u0026#39;), ) def open_spider(self, spider): self.db = pymysql.connect(self.host, self.user, self.password, self.database, charset=\u0026#39;utf8\u0026#39;, port=self.port) self.cursor = self.db.cursor() def close_spider(self, spider): self.db.close() def process_item(self, item, spider): data = dict(item) # data[\u0026#39;imgs\u0026#39;] = data[\u0026#39;image_paths\u0026#39;][0] # del data[\u0026#39;image_paths\u0026#39;] com_id = data.get(\u0026#39;com_id\u0026#39;) agg_time = data.get(\u0026#39;agg_time\u0026#39;) check_sql = \u0026#34;SELECT com_id FROM itjuzi WHERE com_id={} AND agg_time={}\u0026#34;.format(com_id, repr(agg_time)) count = self.cursor.execute(check_sql) if count: print(\u0026#34;*\u0026#34; * 20, \u0026#34;{} {} 已存在\u0026#34;.format(com_id, data.get(\u0026#39;name\u0026#39;))) else: keys = \u0026#39;, \u0026#39;.join(data.keys()) values = \u0026#39;, \u0026#39;.join([\u0026#39;%s\u0026#39;] * len(data)) sql = \u0026#39;INSERT INTO %s (%s) VALUES (%s)\u0026#39; % (\u0026#39;itjuzi\u0026#39;, keys, values) value = tuple([v for v in data.values()]) self.cursor.execute(sql, value) self.db.commit() print(\u0026#34;#\u0026#34; * 20, \u0026#34;{} {} 储存成功\u0026#34;.format(com_id, data.get(\u0026#39;name\u0026#39;))) return item ","permalink":"https://chenzqi.cn/posts/2019/20190401_scrapy-process_item%E6%96%B9%E6%B3%95%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%B0%E5%BD%95/","tags":["框架"],"title":"Scrapy process_item方法写入数据库记录"},{"categories":[2019,"技术"],"contents":":::tip Flask自定义全局响应类 ::: api的设计中, 无论异常还是正常数据均需要服务器以json的格式返回, 为了对异常的统一管理, 同时为了后续更加方便的返回和验证数据, 自定义异常返回类. 设计异常数据的返回格式为: { \u0026#34;error_code\u0026#34;: 999, \u0026#34;msg\u0026#34;: \u0026#34;sorry, we make a mistake\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;POST /v1/client/register\u0026#34; } 重写异常类 定义一个最基本的类, 供其它类继承, 取名为APIException继承HTTPException. 这个功能取一个单独文件存放，方便调用 返回特定的body信息, 需要重写get_body 指定返回类型, 需要重写get_headers 接收自定义的参数, 重写了__init__ 同时定义了类变量作为几个默认参数(code 状态码，error_code 自定义错误码，msg 描述信息) from flask import request, json from werkzeug.exceptions import HTTPException \u0026#34;\u0026#34;\u0026#34; HTTPException: 所有HTTP异常的基类。可以将此异常称为WSGI应用程序， 以呈现默认错误页面，或者您可以独立捕获其子类并呈现更好的错误消息。 \u0026#34;\u0026#34;\u0026#34; class APIException(HTTPException): code = 500 msg = \u0026#39;sorry, we made a mistake (*￣︶￣)!\u0026#39; error_code = 999 def __init__(self, msg=None, code=None, error_code=None, headers=None): if code: self.code = code if error_code: self.error_code = error_code if msg: self.msg = msg super(APIException, self).__init__(msg, None) def get_body(self, environ=None): body = dict( msg=self.msg, error_code=self.error_code, request=request.method + \u0026#39; \u0026#39; + self.get_url_no_param() ) text = json.dumps(body) return text def get_headers(self, environ=None): \u0026#34;\u0026#34;\u0026#34;Get a list of headers.\u0026#34;\u0026#34;\u0026#34; return [(\u0026#39;Content-Type\u0026#39;, \u0026#39;application/json\u0026#39;)] # 获取访问路由，删除参数 @staticmethod def get_url_no_param(): full_path = str(request.full_path) main_path = full_path.split(\u0026#39;?\u0026#39;) return main_path[0] 自定义状态类 from application.libs.error import APIException class Success(APIException): code = 201 msg = \u0026#39;ok\u0026#39; error_code = 0 class DeleteSuccess(Success): code = 202 error_code = -1 class ServerError(APIException): code = 500 msg = \u0026#39;sorry, we made a mistake (*￣︶￣)!\u0026#39; error_code = 999 class ClientTypeError(APIException): # 400 401 403 404 # 500 # 200 201 204 # 301 302 code = 400 msg = \u0026#39;client is invalid\u0026#39; error_code = 1006 class ParameterException(APIException): code = 400 msg = \u0026#39;invalid parameter\u0026#39; error_code = 1000 class NotFound(APIException): code = 404 msg = \u0026#39;the resource are not found O__O...\u0026#39; error_code = 1001 class AuthFailed(APIException): code = 401 error_code = 1005 msg = \u0026#39;authorization failed\u0026#39; class Forbidden(APIException): code = 403 error_code = 1004 msg = \u0026#39;forbidden, not in scope\u0026#39; class DuplicateGift(APIException): code = 400 error_code = 2001 msg = \u0026#39;the current book has already in gift\u0026#39; ","permalink":"https://chenzqi.cn/posts/2019/20190315_flask%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","tags":["框架"],"title":"Flask全局异常处理"},{"categories":[2019,"技术"],"contents":":::tip Flask重写模型序列化 ::: 使用过的序列化方式 在模型定义的时候给序列化的方法 继承 flask 里面的 JSONEncoder类以及default方法 自定义序列化方法 模型定义 class User(BaseModel, UserMixin): __tablename__ = \u0026#39;user\u0026#39; id = db.Column(db.Integer, primary_key=True, autoincrement=True, unique=True) nickname = db.Column(db.String(100)) mobile = db.Column(db.String(20), nullable=False) email = db.Column(db.String(100)) sex = db.Column(db.Integer) password_hash = db.Column(db.String(128), nullable=False) status = db.Column(db.Integer) roles = db.relationship(\u0026#39;Role\u0026#39;, secondary=\u0026#39;roles_users\u0026#39;, backref=db.backref(\u0026#39;users\u0026#39;, lazy=\u0026#39;dynamic\u0026#39;)) # 自定义模型序列化 user.test_schema() def test_schema(self): return { \u0026#39;id\u0026#39;: self.id, \u0026#39;nickname\u0026#39;: self.nickname, \u0026#39;mobile\u0026#39;: self.mobile, \u0026#34;creat_time\u0026#34;: str(self.create_time) } view使用 class UserView(Resource): def __init__(self): self.reqparse = reqparse.RequestParser() def get(self, id): user = User.query.filter_by(id=id).first() # 调用定义方法 data = user.test_schema() return jsonify(data) 重写JSONEncoder 在调用json.dumps()方法时默认会使用JSONEncoder进行序列化，传入cls参数后可以使用自定义的序列化方法，源码解析 def dumps(obj, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw): # cls参数的使用介绍 \u0026#34;\u0026#34;\u0026#34; To use a custom ``JSONEncoder`` subclass (e.g. one that overrides the ``.default()`` method to serialize additional types), specify it with the ``cls`` kwarg; otherwise ``JSONEncoder`` is used. 如果要使用自定义的“JSONEncoder”子类 （例如，重写 default() 方法来序列化其他类型的数据）， 请使用使用“cls”关键字参数；否则默认使用“JSONEncoder”。 \u0026#34;\u0026#34;\u0026#34; # 部分源码：传入了 cls ，就会按照重写的方法执行 if cls is None: cls = JSONEncoder return cls( skipkeys=skipkeys, ensure_ascii=ensure_ascii, check_circular=check_circular, allow_nan=allow_nan, indent=indent, separators=separators, default=default, sort_keys=sort_keys, **kw).encode(obj) 原有JSONEncoder的default()方法是不能够对对象进行序列化，需要重写default()方法，然后在调用json.dumps()时通过cls参数传进去 模型定义 需要在User类中定义keys和getitem方法，然后在default函数中使用dict()函数。 基本上每一个模型类都要进行序列化，所以每一个模型类里都要写 keys、__getitem__方法。把一些公共的方法提取到基类BaseModel里面去 class BaseModel(db.Model): __abstract__ = True create_time = db.Column(db.DateTime, default=datetime.now) update_time = db.Column(db.DateTime, default=datetime.now, onupdate=datetime.now) def __getitem__(self, item): return getattr(self, item) def keys(self): return self.fields # 支持隐藏字段 def hide(self, *keys): for key in keys: self.fields.remove(key) return self # 支持添加字段 def append(self, *keys): for key in keys: self.fields.append(key) return self class User(BaseModel, UserMixin): __tablename__ = \u0026#39;user\u0026#39; id = db.Column(db.Integer, primary_key=True, autoincrement=True, unique=True) nickname = db.Column(db.String(100)) mobile = db.Column(db.String(20), nullable=False) email = db.Column(db.String(100)) sex = db.Column(db.Integer) password_hash = db.Column(db.String(128), nullable=False) status = db.Column(db.Integer) roles = db.relationship(\u0026#39;Role\u0026#39;, secondary=\u0026#39;roles_users\u0026#39;, backref=db.backref(\u0026#39;users\u0026#39;, lazy=\u0026#39;dynamic\u0026#39;)) # SQLALChemy的实例化是不会调用__init__函数，要想调用需要 # from sqlalchemy import orm # @orm.reconstructor这个装饰器 @orm.reconstructor def __init__(self): self.fields = [\u0026#39;id\u0026#39;, \u0026#39;nickname\u0026#39;, \u0026#39;mobile\u0026#39;, \u0026#39;create_time\u0026#39;] 重写JSONEncoder o 对象 from datetime import date from flask import Flask as _Flask, current_app from flask.json import JSONEncoder as _JSONEncoder from application.libs.error_code import ServerError class JSONEncoder(_JSONEncoder): def default(self, o): # 判断，如果对象没有这两个方法的话就返回 ServerError表示服务器内部错误 if hasattr(o, \u0026#39;keys\u0026#39;) and hasattr(o, \u0026#39;__getitem__\u0026#39;): return dict(o) # 兼容其他的序列化 if isinstance(o, date): return o.strftime(\u0026#39;%Y-%m-%d %H:%S\u0026#39;) # 自定义 raise ServerError() # 用我们自定义的 JSONEncoder 替代 Flask 原有的 JSONEncoder class Flask(_Flask): json_encoder = JSONEncoder ","permalink":"https://chenzqi.cn/posts/2019/20190302_flask%E6%A8%A1%E5%9E%8B%E5%BA%8F%E5%88%97%E5%8C%96/","tags":["框架"],"title":"Flask模型序列化"},{"categories":[2019,"技术"],"contents":"把日志相关的配置封装成一个日志初始化函数 import logging from logging.handlers import RotatingFileHandler ...... def setup_log(config_name): dir_file = os.path.abspath(__file__) dir_info = os.path.dirname(dir_file) dir_base = os.path.dirname(dir_info) dir_log = os.path.join(dir_base, \u0026#39;logs/log\u0026#39;) # 设置日志的记录等级 logging.basicConfig(level=config_dict[config_name].LOG_LEVEL) # 调试debug级 # 创建日志记录器，指明日志保存的路径、每个日志文件的最大大小、保存的日志文件个数上限 file_log_handler = RotatingFileHandler(dir_log, maxBytes=1024 * 1024 * 100, backupCount=10) # 创建日志记录的格式 日志等级 输入日志信息的文件名 行数 日志信息 formatter = logging.Formatter(\u0026#39;%(levelname)s %(filename)s:%(lineno)d %(message)s\u0026#39;) # 为刚创建的日志记录器设置日志记录格式 file_log_handler.setFormatter(formatter) # 为全局的日志工具对象（flaskapp使用的）添加日志记录器 logging.getLogger().addHandler(file_log_handler) def create_app(config_str): app = Flask(__name__) app.config.from_object(config_dict.get(config_str)) # 启用日志功能 setup_log(config_str) db.init_app(app) Session(app) return app 手动创建logs文件夹 ","permalink":"https://chenzqi.cn/posts/2019/20190220_flask%E9%85%8D%E7%BD%AE%E9%A1%B9%E7%9B%AE%E6%97%A5%E5%BF%97/","tags":["框架"],"title":"Flask配置项目日志"},{"categories":[2019,"技术"],"contents":"开发中经常用到的项目结构示例 创建shell脚本 使用 shell 脚本快速生成项目基础骨架 脚本文件下载 提取码：xjxe 将下面的脚本保存为文件 generate_flask_boilerplate.sh # !/bin/bash dirname=$1 if [ ! -d \u0026#34;$dirname\u0026#34; ] then mkdir ./$dirname \u0026amp;\u0026amp; cd $dirname mkdir ./application mkdir -p ./application/{controllers,models,static,static/css,static/js,templates} touch {manage.py,requirements.txt} touch ./application/{__init__.py,app.py,configs.py,extensions.py} touch ./application/{controllers/__init__.py,models/__init__.py} touch ./application/{static/css/style.css,templates/404.html,templates/base.html} echo \u0026#34;File created\u0026#34; else echo \u0026#34;File exists\u0026#34; fi 生成项目骨架 Linux sh generate_flask_boilerplate.sh flask-demo Windows 新建项目目录flask-demo并进入 双击shell脚本文件 结构示例 flask-demo ├── application │ ├── __init__.py │ ├── app.py │ ├── configs.py │ ├── controllers │ │ ├── __init__.py │ ├── extensions.py │ ├── models │ │ ├── __init__.py │ ├── static │ │ ├── css │ │ │ └── style.css │ │ └── js │ └── templates │ ├── 404.html │ ├── base.html ├── manage.py ├── requirements.txt 骨架包含三个顶级文件(夹)：application 目录、manage.py 文件和 requirements.txt 文件，一般情况下，可能还需要一个 tests 目录。 application Flask 程序，包含业务逻辑代码、数据模型和静态文件等 configs.py 项目配置 models 数据模型文件 templates 模板文件 static 存放静态文件，如 js、css 等文件 manage.py 启动 Web 程序以及其他的程序任务 requirements.txt 项目的安装依赖包 ","permalink":"https://chenzqi.cn/posts/2019/20190210_flask%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E9%AA%A8%E6%9E%B6/","tags":["框架"],"title":"Flask项目结构基础骨架"},{"categories":[2019,"技术"],"contents":"自定义动态参数缓存键 1 def make_cache_key(): args = request.args key = request.path + \u0026#39;?\u0026#39; + urllib.parse.urlencode([ (k, v) for k in sorted(args) for v in sorted(args.getlist(k)) ]) return key 复杂，好处是即使表单数据顺序打乱，在转换为cache_key时也sorted()过的，不会出现冗余cache的情况 2 def make_cache_key(*args, **kwargs): args = str(hash(frozenset(request.args.items()))) key = str((request.path + args).encode(\u0026#39;utf-8\u0026#39;)) return key 使用 @cache.cached(timeout=600, key_prefix=make_cache_key) def 路由函数： return jsonify(status=200, msg=\u0026#34;\u0026#34;, data=\u0026#34;\u0026#34;) ","permalink":"https://chenzqi.cn/posts/2019/20190205_flask-cache%E7%BC%93%E5%AD%98%E5%8A%A8%E5%8F%82get%E8%AF%B7%E6%B1%82/","tags":["框架"],"title":"Flask-Cache缓存动参GET请求"},{"categories":[2019,"技术"],"contents":"下载所需JDK包 官网下载 JDK包下载： 提取码：2knq 创建存放JDK包文件夹 通过xftp上传至服务器指定路径 [root@ ~]# mkdir /usr/local/java [root@ ~]# cd /usr/local/java [root@ ~]# tar -zxvf ... 配置环境变量 [root@ ~]# vim /etc/profile JAVAHOME=/usr/local/java/解压后名字 PATH=$PATH:$JAVAHOME/bin:/usr/bin:/usr/sbin:/bin:/sbin CLASSPATH=.:$JAVAHOME/lib/tools.jar:$JAVAHOME/lib/dt.jar export JAVAHOME PATH CLASSPATH 生效配置 [root@ ~]# source /etc/profile 验证 [root@ ~]# java -version ","permalink":"https://chenzqi.cn/posts/2019/20190120_centos%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEjdk/","tags":["linux"],"title":"CentOS安装配置jdk"},{"categories":[2019,"技术"],"contents":"sh脚本异常：/bin/sh^M:bad interpreter: No such file or directory 分析：这是不同系统编码格式引起的：在windows系统中编辑的.sh文件可能有不可见字符，所以在Linux系统下执行会报以上异常信息。 首先要确保文件有可执行权限 sh\u0026gt;chmod a+x filename 然后修改文件格式 sh\u0026gt;vi filename 利用如下命令查看文件格式 :**set ff **或 :set fileformat 可以看到如下信息 fileformat=dos 或 fileformat=unix 利用如下命令修改文件格式 :set ff=unix 或 :set fileformat=unix :wq (存盘退出) 最后再执行文件 sh\u0026gt;./filename ","permalink":"https://chenzqi.cn/posts/2019/20190111_sh%E8%84%9A%E6%9C%AC%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E5%BC%82%E5%B8%B8/","tags":["linux"],"title":"sh脚本编码异常：binsh^Mbad interpreter No such file or directory"},{"categories":null,"contents":"","permalink":"https://chenzqi.cn/search/","tags":null,"title":"Search"},{"categories":null,"contents":"年轻的时候，我们都有一个梦想，长大以后要带着父母环游世界。 但是等我们真正成年或者娶妻生子了，却总是忘了和父母联系。 不记得他们的生日，也不关心他们的身体，即使有时候回家和他们坐在一起，也总是感觉和他们聊不到一块。 我们开始嫌弃他们唠叨、不爱卫生、爱贪小便宜、管得太多……想和他们保持距离。 成年或者是独立以后，不要说带父母去环游世界了，就连他们生病或者离开人世的时候， 也许我们都没有陪他们去医院或者是留在他们的身边。 曾经在网上看到过一个视频，一个老母亲因为三个儿子从未回家探望过她，便把自己的三个儿子告上了法院，要求他们支付九个月的“房费”。 这个老母亲其实并不差钱，她之所以这么做，无非就是想提醒自己的孩子们记得常回家看看，不要忘了她。 生儿育女，父母要的其实并不多，他们只是希望在垂暮之年有儿女们的惦念或者是陪伴，足矣。 “父母在，人生尚有来处；父母去，人生只剩归途。” 有着未来想带父母远游的心，不如先试着多给父母打几次电话。听听他们唠唠家常，讲讲自己最近的生活过得怎么样。 与其给未来许下陪伴的梦想，不如珍惜当下的幸福时光。 一味地观望与等待，只会是虚无中的精彩。朋友不等你，爱人不等你，父母不等你，孩子不等你，即使有些东西在等你，可是光阴不等你。 当你失去了，后悔了，还能做什么？还能去哪里呢？ 生活中，有太多的事情是我们不能控制的。明明约定好了的事情，本来信心满满地期待着它的发生，结果路走到一半就遭遇厄运，曾经约定好的事情却难以维持下去。 我们的岁月不长，不长，容不下慢慢地去细想。 时光很急，很急，不要等到一切来不及。 ","permalink":"https://chenzqi.cn/about/%E5%85%B3%E4%BA%8E/","tags":null,"title":"关于"},{"categories":null,"contents":" ★小伙伴★ 极客小祥的博客 \"永远相信美好的事情即将发生\" 在线工具 新工具网 \"在线工具箱\" iLoveIMG \"可批量编辑图片的所有工具\" 图标工厂 \"移动应用图标/启动图生成，iOS、Android图标工具\" ","permalink":"https://chenzqi.cn/friends/","tags":null,"title":"友链墙"},{"categories":null,"contents":"随着快门📸的开启，时间被凝固下来，作为”此时此刻”的记录是不可重复的，也就成为永远。🏞 2022-8 迪士尼之旅 🎡🎢 交通：🚅 🚇 天气：🌞 \u003c!DOCTYPE html\u003e ","permalink":"https://chenzqi.cn/about/photo/","tags":null,"title":"相册"}]